{
    "0": {
        "file_id": 0,
        "content": "/README.md",
        "type": "filepath"
    },
    "1": {
        "file_id": 0,
        "content": "The code introduces a project for video segmentation, pose detection, and audio analysis with plans to create an app that automatically uploads videos to bilibili.com. It provides installation instructions, software architecture details, and contribution guidelines along with links to relevant resources.",
        "type": "summary"
    },
    "2": {
        "file_id": 0,
        "content": "# AutoUP\n## Description\nTo automatically make and upload videos to bilibili.com.\n## Core Tech\n- https://github.com/search?q=video+segmentation\n- https://github.com/MVIG-SJTU/AlphaPose\n- https://www.analyticsvidhya.com/blog/2019/04/introduction-image-segmentation-techniques-python/?utm_source=blog&utm_medium=computer-vision-implementing-mask-r-cnn-image-segmentation\n- https://github.com/Yonv1943/Unsupervised-Segmentation\n- https://github.com/carrierlxk/COSNet\n- https://github.com/rsennrich/subword-nmt\n- https://github.com/mickaelChen/ReDO\n- https://gitee.com/x00e0d991e368/Mask_RCNN\n- https://github.com/search?q=body+pose\n- https://github.com/deepfakes/faceswap\n- https://github.com/search?q=video+classification\n- https://github.com/weiaicunzai/awesome-image-classification\n- https://gitee.com/ouhuber/Ossas_ChatBot\n- https://gitee.com/x00e0d991e368/EssayKiller_v2\n- https://gitee.com/DataTraveler_0817/Real-Time-Voice-Cloning\n- https://github.com/tyiannak/pyAudioAnalysis\n- https://github.com/search?q=music+generate",
        "type": "code",
        "location": "/README.md:1-25"
    },
    "3": {
        "file_id": 0,
        "content": "This code contains a list of links to various technologies related to video segmentation, pose detection, image and video classification, audio analysis, and music generation. These resources can be used in developing an application that automatically makes and uploads videos to bilibili.com.",
        "type": "comment"
    },
    "4": {
        "file_id": 0,
        "content": "- https://github.com/danieldjohnson/biaxial-rnn-music-composition\n- https://github.com/openai/jukebox\n- https://github.com/librosa/librosa\n- https://github.com/google/REAPER\n- https://pypi.org/project/crepe\n- https://github.com/ChenChengKuan/awesome-text-generation\n- https://github.com/bearpelican/musicautobot\n- https://www.small-text-generator.com/?m=1\n- https://github.com/Tony607/colab-mask-rcnn\n- https://github.com/seoungwugoh/RGMP\n- https://github.com/JialeCao001/SipMask\n- https://dl.acm.org/doi/10.1145/1963564.1963586\n- https://pjreddie.com/darknet/yolo/\n- https://github.com/CVUsers/Auto_maker\n...\nAnd, of course: scraping!\n## Scraping sources\n- QQ chats\n- bilibili info\n- baidu\n- weibo\n...\n## Discoveries\nAPI of bilibili posting does not allow multiple videos with identical title to be submitted simutaneously. Consider some method to tweak the title somehow.\nThe posting metadata can be fetched from local server, thanks to tornado.\n## Roadmap\nCurrently collecting, mixing and uploading video is partially complete.",
        "type": "code",
        "location": "/README.md:26-62"
    },
    "5": {
        "file_id": 0,
        "content": "The code provides a list of resources and APIs related to text and audio generation, scraping sources such as QQ chats, bilibili info, and baidu. The current progress of the project is collecting, mixing, and uploading videos, which is partially complete. The API of bilibili posting does not allow multiple videos with identical titles to be submitted simultaneously, requiring a method to tweak the title for submission.",
        "type": "comment"
    },
    "6": {
        "file_id": 0,
        "content": "### TODO:\n- Streaming redirection.\n- Metadata generation.\n- Automatic info collection.\n- Advanced video mingle technique.\n- TTS.\n- Markov text generation.\n- Automatic video categorization.\n- More video processors and more video sources.\n- Music scraping, Webpic scraping, (general scraping).\n## Software Architecture\nCookie getter from the browser via Lazero Chrome Plugin (version Apollo), or use the embedded automatic login tool under `poster/bilibiliupload` by configuring credentials in config.yaml.\n## Installation\n1.  Install Lazero Plugin for Chrome (under `chrome_plugins/lazero_crx_16`\n2.  Install dependencies via `./init.sh`\n3.  Happy Hacking!\n## Instructions\n1.  Do not rely on me, cause I'm only developing my own little project.\n2.  The resources are exhaustive but still, you need to try it yourself.\n3.  Never give up!\n## Contribution\n1.  Fork the repository\n2.  Create new branch\n3.  Commit your code\n4.  Create Pull Request\n## Gitee Feature\n1.  You can use Readme\\_XXX.md to support different languages, such as Readme\\_en.md, Readme\\_zh.md",
        "type": "code",
        "location": "/README.md:64-110"
    },
    "7": {
        "file_id": 0,
        "content": "This code is an introduction to a project with various TODO features and software architecture details, installation instructions, and contribution guidelines. It requires installing the Lazero Plugin for Chrome and setting up dependencies. The main goal is to provide a comprehensive guide for users to understand the project's purpose and contribute effectively.",
        "type": "comment"
    },
    "8": {
        "file_id": 0,
        "content": "2.  Gitee blog [blog.gitee.com](https://blog.gitee.com)\n3.  Explore open source project [https://gitee.com/explore](https://gitee.com/explore)\n4.  The most valuable open source project [GVP](https://gitee.com/gvp)\n5.  The manual of Gitee [https://gitee.com/help](https://gitee.com/help)\n6.  The most popular members  [https://gitee.com/gitee-stars/](https://gitee.com/gitee-stars/)",
        "type": "code",
        "location": "/README.md:111-115"
    },
    "9": {
        "file_id": 0,
        "content": "This code provides links to various sections of Gitee, including a blog, open source projects, valuable open source projects, help documentation, and a list of popular members.",
        "type": "comment"
    },
    "10": {
        "file_id": 1,
        "content": "/bilibiliupload_failsafe.sh",
        "type": "filepath"
    },
    "11": {
        "file_id": 1,
        "content": "Copies bilibili_cookies_full.json from the confidential directory to bilibili_persistent.json in the same directory, preserving the file contents for future use.",
        "type": "summary"
    },
    "12": {
        "file_id": 1,
        "content": "#!/bin/bash\npre=.confidential\ncp $pre/bilibili_cookies_full.json $pre/bilibili_persistent.json",
        "type": "code",
        "location": "/bilibiliupload_failsafe.sh:1-3"
    },
    "13": {
        "file_id": 1,
        "content": "Copies bilibili_cookies_full.json from the confidential directory to bilibili_persistent.json in the same directory, preserving the file contents for future use.",
        "type": "comment"
    },
    "14": {
        "file_id": 2,
        "content": "/collector/bili_info_collect/README.md",
        "type": "filepath"
    },
    "15": {
        "file_id": 2,
        "content": "This code outlines the main directions and functions of a project, which involves analyzing various aspects of videos, images, audio, comments, and more on a platform. It includes features like trend prediction, video cut detection, text recognition, categorization, statistics, and resource timeline syncing for metadata analysis.",
        "type": "summary"
    },
    "16": {
        "file_id": 2,
        "content": "# project brief\n## main direction:\n- per video spect\n- per essay spect\n- per uploader/viewer spect\n- comments\n- home suggestions\n- search suggestions\n- what's next list\n- monitor change\n- categories in main page\n- subpages\n- search\n- ads\n- dynamic\n## main functions:\n- value assignment/prediction\n- trend prediction\n- video cut detection\n- video/image mask/reigion tracing/scooping\n- video/image text recognization\n- video/image categorization\n- video/image statistics\n- audio cut\n- audio tune detect\n- audio tempo detect\n- audio categorizaion\n- audio statistics\n- danmaku/comments/dynamic analyzation\n- resource timeline sync\n- metadata analysis\n- video/image/audio/font source tracking\n- template extraction\n- fidelity",
        "type": "code",
        "location": "/collector/bili_info_collect/README.md:1-38"
    },
    "17": {
        "file_id": 2,
        "content": "This code outlines the main directions and functions of a project, which involves analyzing various aspects of videos, images, audio, comments, and more on a platform. It includes features like trend prediction, video cut detection, text recognition, categorization, statistics, and resource timeline syncing for metadata analysis.",
        "type": "comment"
    },
    "18": {
        "file_id": 3,
        "content": "/collector/celeb_picture_collect/baidu_spider.js",
        "type": "filepath"
    },
    "19": {
        "file_id": 3,
        "content": "This code utilizes Electron and defines a downloadFile function with progress tracking, incorporates base64 library functions, adds base64 methods to String and Uint8Array, downloads images, creates BrowserWindows, interacts with an App object for events and quitting, and may function as a web crawler/scraper.",
        "type": "summary"
    },
    "20": {
        "file_id": 3,
        "content": "const electron = require ('electron')\nvar fs = require(\"fs\")\nvar request = require(\"request\");\n// const { resolve } = require('path');\n// the number is plenty now.\nvar pargs = process.argv;\npargs.shift();\npargs.shift();\n// assume there is some name over the spot.\n// base64 urlsafe decode.\n// console.log(args)\nconst app = electron.app // electron module\nconst BrowserWindow = electron.BrowserWindow //enables UI\n// const Menu = electron.Menu // menu module\n// to disable the window?\nvar resolved =0;\nvar previous=0;\nfunction downloadFile(file_url , targetPath){\n    // Save variable to know progress\n    resolved+=1;\n    var received_bytes = 0;\n    var total_bytes = 0;\n    var req = request({\n        method: 'GET',\n        uri: file_url\n    });\n    var out = fs.createWriteStream(targetPath);\n    req.pipe(out);\n    req.on('response', function ( data ) {\n        // Change the total bytes value to get progress later.\n        total_bytes = parseInt(data.headers['content-length' ]);\n    });\n    req.on('data', function(chunk) {\n        // Update the received bytes",
        "type": "code",
        "location": "/collector/celeb_picture_collect/baidu_spider.js:1-38"
    },
    "21": {
        "file_id": 3,
        "content": "This code uses the Electron framework and requires modules such as fs (file system) and request. It defines variables for resolved and previous, and creates a downloadFile function to save files with progress tracking. The function takes a file URL and target path as parameters, creates a write stream, pipes the request data into the stream, and updates received bytes and total bytes on events.",
        "type": "comment"
    },
    "22": {
        "file_id": 3,
        "content": "        received_bytes += chunk.length;\n        showProgress(received_bytes, total_bytes);\n    });\n    req.on('end', function() {\n        // this one is not good.\n        resolved -=1;\n        console.log(\"File succesfully downloaded\");\n    });\n}\nfunction showProgress(received,total){\n    var percentage = (received * 100) / total;\n    console.log(percentage + \"% | \" + received + \" bytes out of \" + total + \" bytes.\");\n}\nconst gBase64 = function() {\n/**\n *  base64.ts\n *\n *  Licensed under the BSD 3-Clause License.\n *    http://opensource.org/licenses/BSD-3-Clause\n *\n *  References:\n *    http://en.wikipedia.org/wiki/Base64\n *\n * @author Dan Kogai (https://github.com/dankogai)\n */\nconst version = '3.6.0';\n/**\n * @deprecated use lowercase `version`.\n */\nconst VERSION = version;\nconst _hasatob = typeof atob === 'function';\nconst _hasbtoa = typeof btoa === 'function';\nconst _hasBuffer = typeof Buffer === 'function';\nconst _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;\nconst _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;",
        "type": "code",
        "location": "/collector/celeb_picture_collect/baidu_spider.js:39-77"
    },
    "23": {
        "file_id": 3,
        "content": "Function `showProgress` displays the progress of a file download in percentage and bytes received vs total bytes. The code is using `req.on('data')` to listen for data chunks during the download, updating the received bytes and calling `showProgress` to display progress. Upon completing the download, it logs \"File succesfully downloaded\". The code also imports a function from \"base64.ts\" library.",
        "type": "comment"
    },
    "24": {
        "file_id": 3,
        "content": "const b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nconst b64chs = [...b64ch];\nconst b64tab = ((a) => {\n    let tab = {};\n    a.forEach((c, i) => tab[c] = i);\n    return tab;\n})(b64chs);\nconst b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\nconst _fromCC = String.fromCharCode.bind(String);\nconst _U8Afrom = typeof Uint8Array.from === 'function'\n    ? Uint8Array.from.bind(Uint8Array)\n    : (it, fn = (x) => x) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));\nconst _mkUriSafe = (src) => src\n    .replace(/[+\\/]/g, (m0) => m0 == '+' ? '-' : '_')\n    .replace(/=+$/m, '');\nconst _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\\+\\/]/g, '');\n/**\n * polyfill version of `btoa`\n */\nconst btoaPolyfill = (bin) => {\n    // console.log('polyfilled');\n    let u32, c0, c1, c2, asc = '';\n    const pad = bin.length % 3;\n    for (let i = 0; i < bin.length;) {\n        if ((c0 = bin.charCodeAt(i++)) > 255 ||\n            (c1 = bin.charCodeAt(i++)) > 255 ||\n            (c2 = bin.charCodeAt(i++)) > 255)",
        "type": "code",
        "location": "/collector/celeb_picture_collect/baidu_spider.js:78-104"
    },
    "25": {
        "file_id": 3,
        "content": "This code snippet defines a polyfill for the `btoa` function and includes helper functions. The `btoaPolyfill` function converts binary data to Base64, while other functions like `_mkUriSafe`, `_tidyB64`, and `String.fromCharCode` are used for string manipulation.",
        "type": "comment"
    },
    "26": {
        "file_id": 3,
        "content": "            throw new TypeError('invalid character found');\n        u32 = (c0 << 16) | (c1 << 8) | c2;\n        asc += b64chs[u32 >> 18 & 63]\n            + b64chs[u32 >> 12 & 63]\n            + b64chs[u32 >> 6 & 63]\n            + b64chs[u32 & 63];\n    }\n    return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n};\n/**\n * does what `window.btoa` of web browsers do.\n * @param {String} bin binary string\n * @returns {string} Base64-encoded string\n */\nconst _btoa = _hasbtoa ? (bin) => btoa(bin)\n    : _hasBuffer ? (bin) => Buffer.from(bin, 'binary').toString('base64')\n        : btoaPolyfill;\nconst _fromUint8Array = _hasBuffer\n    ? (u8a) => Buffer.from(u8a).toString('base64')\n    : (u8a) => {\n        // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326\n        const maxargs = 0x1000;\n        let strs = [];\n        for (let i = 0, l = u8a.length; i < l; i += maxargs) {\n            strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));",
        "type": "code",
        "location": "/collector/celeb_picture_collect/baidu_spider.js:105-129"
    },
    "27": {
        "file_id": 3,
        "content": "This code defines a function that converts binary data into a Base64-encoded string, which is similar to `window.btoa` in web browsers. It uses either the native `btoa()` method if available, or falls back to a Buffer conversion if possible. If neither are available, it uses a polyfill implementation. The code also defines a separate function for converting Uint8Array to Base64-encoded strings.",
        "type": "comment"
    },
    "28": {
        "file_id": 3,
        "content": "        }\n        return _btoa(strs.join(''));\n    };\n/**\n * converts a Uint8Array to a Base64 string.\n * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5\n * @returns {string} Base64 string\n */\nconst fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const utob = (src: string) => unescape(encodeURIComponent(src));\n// reverting good old fationed regexp\nconst cb_utob = (c) => {\n    if (c.length < 2) {\n        var cc = c.charCodeAt(0);\n        return cc < 0x80 ? c\n            : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))\n                + _fromCC(0x80 | (cc & 0x3f)))\n                : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))\n                    + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n                    + _fromCC(0x80 | (cc & 0x3f)));\n    }\n    else {\n        var cc = 0x10000\n            + (c.charCodeAt(0) - 0xD800) * 0x400\n            + (c.charCodeAt(1) - 0xDC00);\n        return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))",
        "type": "code",
        "location": "/collector/celeb_picture_collect/baidu_spider.js:130-156"
    },
    "29": {
        "file_id": 3,
        "content": "This code defines two functions: one for converting a string into a Base64 representation, and another for converting a Uint8Array to a Base64 string. The code also includes a function that handles Unicode surrogate pairs for compatibility with older browsers.",
        "type": "comment"
    },
    "30": {
        "file_id": 3,
        "content": "            + _fromCC(0x80 | ((cc >>> 12) & 0x3f))\n            + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n            + _fromCC(0x80 | (cc & 0x3f)));\n    }\n};\nconst re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-8 string\n * @returns {string} UTF-16 string\n */\nconst utob = (u) => u.replace(re_utob, cb_utob);\n//\nconst _encode = _hasBuffer\n    ? (s) => Buffer.from(s, 'utf8').toString('base64')\n    : _TE\n        ? (s) => _fromUint8Array(_TE.encode(s))\n        : (s) => _btoa(utob(s));\n/**\n * converts a UTF-8-encoded string to a Base64 string.\n * @param {boolean} [urlsafe] if `true` make the result URL-safe\n * @returns {string} Base64 string\n */\nconst encode = (src, urlsafe = false) => urlsafe\n    ? _mkUriSafe(_encode(src))\n    : _encode(src);\n/**\n * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.\n * @returns {string} Base64 string\n */\nconst encodeURI = (src) => encode(src, true);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130",
        "type": "code",
        "location": "/collector/celeb_picture_collect/baidu_spider.js:157-188"
    },
    "31": {
        "file_id": 3,
        "content": "This code is a JavaScript function that converts a UTF-8 encoded string to Base64. It provides an \"encode\" function which takes in a source string and an optional boolean for URL-safety, and returns the Base64 representation of the input. It also includes a separate \"encodeURI\" function that performs the same task but ensures the output is URL safe according to RFC4648 §5. The code uses various internal functions and libraries like _hasBuffer, _TE, _fromUint8Array, and _btoa for different conversion tasks. Note that the 'utob' function is deprecated and used internally in this codebase.",
        "type": "comment"
    },
    "32": {
        "file_id": 3,
        "content": "// const btou = (src: string) => decodeURIComponent(escape(src));\n// reverting good old fationed regexp\nconst re_btou = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g;\nconst cb_btou = (cccc) => {\n    switch (cccc.length) {\n        case 4:\n            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)\n                | ((0x3f & cccc.charCodeAt(1)) << 12)\n                | ((0x3f & cccc.charCodeAt(2)) << 6)\n                | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;\n            return (_fromCC((offset >>> 10) + 0xD800)\n                + _fromCC((offset & 0x3FF) + 0xDC00));\n        case 3:\n            return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)\n                | ((0x3f & cccc.charCodeAt(1)) << 6)\n                | (0x3f & cccc.charCodeAt(2)));\n        default:\n            return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)\n                | (0x3f & cccc.charCodeAt(1)));\n    }\n};\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-16 string\n * @returns {string} UTF-8 string",
        "type": "code",
        "location": "/collector/celeb_picture_collect/baidu_spider.js:189-213"
    },
    "33": {
        "file_id": 3,
        "content": "This code contains a regular expression (re_btou) and a function (cb_btou) for converting UTF-16 encoded strings to UTF-8. It uses different logic depending on the length of the input string, with support for 3 and 4 byte characters. The code also includes a deprecated note on the function being intended for internal use only.",
        "type": "comment"
    },
    "34": {
        "file_id": 3,
        "content": " */\nconst btou = (b) => b.replace(re_btou, cb_btou);\n/**\n * polyfill version of `atob`\n */\nconst atobPolyfill = (asc) => {\n    // console.log('polyfilled');\n    asc = asc.replace(/\\s+/g, '');\n    if (!b64re.test(asc))\n        throw new TypeError('malformed base64.');\n    asc += '=='.slice(2 - (asc.length & 3));\n    let u24, bin = '', r1, r2;\n    for (let i = 0; i < asc.length;) {\n        u24 = b64tab[asc.charAt(i++)] << 18\n            | b64tab[asc.charAt(i++)] << 12\n            | (r1 = b64tab[asc.charAt(i++)]) << 6\n            | (r2 = b64tab[asc.charAt(i++)]);\n        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)\n            : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)\n                : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);\n    }\n    return bin;\n};\n/**\n * does what `window.atob` of web browsers do.\n * @param {String} asc Base64-encoded string\n * @returns {string} binary string\n */\nconst _atob = _hasatob ? (asc) => atob(_tidyB64(asc))\n    : _hasBuffer ? (asc) => Buffer.from(asc, 'base64').toString('binary')",
        "type": "code",
        "location": "/collector/celeb_picture_collect/baidu_spider.js:214-243"
    },
    "35": {
        "file_id": 3,
        "content": "This code snippet provides a polyfill for the `atob` function, which is used to decode Base64-encoded strings into binary strings. If the `window.atob` function exists (indicating that the code is running in a web browser), it uses the built-in implementation. Otherwise, if `Buffer` is available, it converts the Base64 string to a Buffer object and then converts it to a binary string. The `_tidyB64` function trims any extra whitespace from the input string before encoding or decoding. This code ensures compatibility across different environments and provides a consistent way of decoding Base64 strings.",
        "type": "comment"
    },
    "36": {
        "file_id": 3,
        "content": "        : atobPolyfill;\n//\nconst _toUint8Array = _hasBuffer\n    ? (a) => _U8Afrom(Buffer.from(a, 'base64'))\n    : (a) => _U8Afrom(_atob(a), c => c.charCodeAt(0));\n/**\n * converts a Base64 string to a Uint8Array.\n */\nconst toUint8Array = (a) => _toUint8Array(_unURI(a));\n//\nconst _decode = _hasBuffer\n    ? (a) => Buffer.from(a, 'base64').toString('utf8')\n    : _TD\n        ? (a) => _TD.decode(_toUint8Array(a))\n        : (a) => btou(_atob(a));\nconst _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == '-' ? '+' : '/'));\n/**\n * converts a Base64 string to a UTF-8 string.\n * @param {String} src Base64 string.  Both normal and URL-safe are supported\n * @returns {string} UTF-8 string\n */\nconst decode = (src) => _decode(_unURI(src));\n/**\n * check if a value is a valid Base64 string\n * @param {String} src a value to check\n  */\nconst isValid = (src) => {\n    if (typeof src !== 'string')\n        return false;\n    const s = src.replace(/\\s+/g, '').replace(/=+$/, '');\n    return !/[^\\s0-9a-zA-Z\\+/]/.test(s) || !/[^\\s0-9a-zA-Z\\-_]/.test(s);",
        "type": "code",
        "location": "/collector/celeb_picture_collect/baidu_spider.js:244-274"
    },
    "37": {
        "file_id": 3,
        "content": "This code provides functions to convert Base64 strings to Uint8Array and UTF-8 strings. The 'toUint8Array' function converts a Base64 string to a Uint8Array, and the 'decode' function converts a Base64 string to a UTF-8 string. Additionally, the code includes an 'isVali",
        "type": "comment"
    },
    "38": {
        "file_id": 3,
        "content": "};\n//\nconst _noEnum = (v) => {\n    return {\n        value: v, enumerable: false, writable: true, configurable: true\n    };\n};\n/**\n * extend String.prototype with relevant methods\n */\nconst extendString = function () {\n    const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));\n    _add('fromBase64', function () { return decode(this); });\n    _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });\n    _add('toBase64URI', function () { return encode(this, true); });\n    _add('toBase64URL', function () { return encode(this, true); });\n    _add('toUint8Array', function () { return toUint8Array(this); });\n};\n/**\n * extend Uint8Array.prototype with relevant methods\n */\nconst extendUint8Array = function () {\n    const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));\n    _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });\n    _add('toBase64URI', function () { return fromUint8Array(this, true); });\n    _add('toBase64URL', function () { return fromUint8Array(this, true); });",
        "type": "code",
        "location": "/collector/celeb_picture_collect/baidu_spider.js:275-300"
    },
    "39": {
        "file_id": 3,
        "content": "This code extends the String.prototype and Uint8Array.prototype with relevant methods related to base64 encoding and decoding, as well as converting strings and Uint8Arrays to Uint8Arrays. The _noEnum function ensures properties are not enumerable while extendString and extendUint8Array functions use Object.defineProperty to add new methods to the respective prototypes.",
        "type": "comment"
    },
    "40": {
        "file_id": 3,
        "content": "};\n/**\n * extend Builtin prototypes with relevant methods\n */\nconst extendBuiltins = () => {\n    extendString();\n    extendUint8Array();\n};\nconst gBase64 = {\n    version: version,\n    VERSION: VERSION,\n    atob: _atob,\n    atobPolyfill: atobPolyfill,\n    btoa: _btoa,\n    btoaPolyfill: btoaPolyfill,\n    fromBase64: decode,\n    toBase64: encode,\n    encode: encode,\n    encodeURI: encodeURI,\n    encodeURL: encodeURI,\n    utob: utob,\n    btou: btou,\n    decode: decode,\n    isValid: isValid,\n    fromUint8Array: fromUint8Array,\n    toUint8Array: toUint8Array,\n    extendString: extendString,\n    extendUint8Array: extendUint8Array,\n    extendBuiltins: extendBuiltins,\n};\n    //\n    // export Base64 to the namespace\n    //\n    // ES5 is yet to have Object.assign() that may make transpilers unhappy.\n    // gBase64.Base64 = Object.assign({}, gBase64);\n    gBase64.Base64 = {};\n    Object.keys(gBase64).forEach(k => gBase64.Base64[k] = gBase64[k]);\n    return gBase64;\n};\nconst Base64 = gBase64();\n// console.log(pargs[0]);\n// make request first?",
        "type": "code",
        "location": "/collector/celeb_picture_collect/baidu_spider.js:301-344"
    },
    "41": {
        "file_id": 3,
        "content": "This code exports the Base64 utility functions to the global namespace and provides methods for encoding and decoding base64 strings, as well as handling Uint8Array data. It also includes polyfills for atob and btoa in case they're not available in the browser.",
        "type": "comment"
    },
    "42": {
        "file_id": 3,
        "content": "// or just read from file.\nfunction urlsafe(string){\n    let result = string.replace(\"=\",\"\").replace(\"+\",\"-\").replace(\"/\",\"_\")\n    return result\n}\nfunction quitfunc(){\n    console.log(\"pending jobs:\",resolved)\n    if(resolved <10 ){app.quit();}\n    else if((previous-resolved)<5){app.quit();\n    }else{previous = resolved;setInterval(()=>{quitfunc()},1000)}\n}\nfunction uuidv4() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n      return v.toString(16);\n    });\n  }\nfunction _h(){console.log(\"specify exact 1 b64_urlsafe encoded query word!\")}\napp.on('ready', _ => {\n    var mainWord=\"\";\n    var orig = pargs[0];\n    if (pargs.length!=1){\n        _h();\n        app.quit();}else{\n            try{\n            mainWord =Base64.decode(pargs[0]);console.log(mainWord)}catch(e){console.log(e);_h();}\n        }\n    // app.quit();\n    mainWord = encodeURI(mainWord);\n    console.log(\"final result:\",mainWord);\n    // mainWord = encodeURI(mainWord);",
        "type": "code",
        "location": "/collector/celeb_picture_collect/baidu_spider.js:345-375"
    },
    "43": {
        "file_id": 3,
        "content": "This code defines several functions. The `urlsafe` function converts a string to URL-safe format by replacing specific characters. The `quitfunc` function checks the number of resolved jobs and quits the application if necessary. `uuidv4` generates a random UUID version 4. The `_h` function displays an error message when an incorrect query word is used. Finally, the code handles the main word by decoding, encoding it for URL safety, and logs the final result.",
        "type": "comment"
    },
    "44": {
        "file_id": 3,
        "content": "    // app.commandLine.hasSwitch();\n    win = new BrowserWindow({\n    width: 800,\n    height: 600,\n    show:false // here's the magic.\n    })\n    var url =\"https://image.baidu.com/search/flip?tn=baiduimage&ie=utf-8&word=\"+mainWord+\"&pn=0&gsm=50&ct=&ic=0&lm=-1&width=0&height=0\"\n    // var url0 =\"https://image.baidu.com/search/flip?tn=baiduimage&ie=utf-8&word=\"+mainWord+\"&pn=1&gsm=50&ct=&ic=0&lm=-1&width=0&height=0\"\n    // const menu = Menu.buildFromTemplate (template) // sets the menu\n    const somecode = `var getlink = document.getElementsByClassName(\"imglink\");var dataOutput = {};for (let links of getlink){for (let link of links.childNodes){try{if (link.tagName.toLowerCase() == \"img\") {dataOutput[link.getAttribute(\"src\")]=link.getAttribute(\"alt\").replace(\"<strong>\",\"\").replace(\"</strong>\",\"\")}}catch(e){}}};dataOutput;`;\nwin.loadURL(url)    // loads this URL\n// reuse the code.\nvar counter = 0;\nvar picount=0;\nvar contents = win.webContents;\ncontents.on(\"did-finish-load\",()=>{contents.executeJavaScript(somecode).then((r)=>{/*console.log(r);*/for (let src in r){",
        "type": "code",
        "location": "/collector/celeb_picture_collect/baidu_spider.js:376-391"
    },
    "45": {
        "file_id": 3,
        "content": "This code creates a new BrowserWindow with a specified width and height, hides it initially, and then loads a URL from Baidu. The JavaScript code inside retrieves image links and their alt tags from the loaded page, stores them in an object, and returns it for further processing.",
        "type": "comment"
    },
    "46": {
        "file_id": 3,
        "content": "    console.log(\"try to download\", src)\n    let meta = uuidv4();\n    // not using this one.\n    if (src.endsWith(\".jpg\")){downloadFile(src,`celeb_pictures/${orig}[ts]${Date.now()}[p]${picount}[m]${meta}.jpg`);picount++;}\n    else if (src.endsWith(\".jpeg\")){downloadFile(src,`celeb_pictures/${orig}[ts]${Date.now()}[p]${picount}[m]${meta}.jpeg`);picount++;}\n    else if (src.endsWith(\".png\")){downloadFile(src,`celeb_pictures/${orig}[ts]${Date.now()}[p]${picount}[m]${meta}.png`);picount++;}\n    }/*not just loggint it!*/if (counter<5){counter+=1;url =\"https://image.baidu.com/search/flip?tn=baiduimage&ie=utf-8&word=\"+mainWord+\"&pn=\"+counter+\"&gsm=50&ct=&ic=0&lm=-1&width=0&height=0\";win.loadURL(url)}else{/*console.dir(app)*/quitfunc();}})})\n// App {\n//     _events: [Object: null prototype] {\n//       'certificate-error': [Function],\n//       'select-client-certificate': [Function],\n//       quit: [Function],\n//       'window-all-closed': [Function],\n//       ready: [Function]\n//     },\n//     _eventsCount: 5,",
        "type": "code",
        "location": "/collector/celeb_picture_collect/baidu_spider.js:392-407"
    },
    "47": {
        "file_id": 3,
        "content": "This code is trying to download a picture from a given source, checking its format (JPG, JPEG, PNG) and appending a unique meta identifier, then saving it in the \"celeb_pictures\" folder. It also has a loop that loads different URLs containing a search word in a Baidu image search, with a limit of 5 URLs. The code is interacting with an App object which has event listeners and a quit function.",
        "type": "comment"
    },
    "48": {
        "file_id": 3,
        "content": "//     _maxListeners: undefined,\n//     commandLine: {\n//       hasSwitch: [Function: hasSwitch],\n//       getSwitchValue: [Function: getSwitchValue],\n//       appendSwitch: [Function: appendSwitch],\n//       appendArgument: [Function: appendArgument]\n//     },\n//     _setDefaultAppPaths: [Function],\n//     [Symbol(kCapture)]: false\n//   }\n// post this shit elsewhere. enable the downloader.\n    // how to execute javascript on the shit?\n})",
        "type": "code",
        "location": "/collector/celeb_picture_collect/baidu_spider.js:408-420"
    },
    "49": {
        "file_id": 3,
        "content": "This code appears to be configuring various functions and settings for a spider, possibly a web crawler or scraper. It mentions enabling the downloader but doesn't explicitly state what it does. It also suggests that there is an intention to execute JavaScript on something, likely referring to processing and scraping JavaScript content from target websites.",
        "type": "comment"
    },
    "50": {
        "file_id": 4,
        "content": "/collector/celeb_picture_collect/collect_pics.py",
        "type": "filepath"
    },
    "51": {
        "file_id": 4,
        "content": "This Python script reads a file, randomly selects pictures if needed, runs baidu_spider.js on encoded base64 picture names using electron.cmd, counts image files in the \"celeb_pictures\" directory, and prints messages based on image availability.",
        "type": "summary"
    },
    "52": {
        "file_id": 4,
        "content": "# coding: UTF-8\nimport sys\nimport os\n# import time\nimport base64\nimport random\nimport pickle\nimport urllib.parse\nsysrand = random.SystemRandom()\ndef escaped(string):\n    result = urllib.parse.quote(string.encode(\"utf-8\"))\n    return result\ndef encoded(string):\n    return base64.urlsafe_b64encode(string.encode(\"utf-8\")).decode(\"utf-8\")\n# you would just randomly select pictures?\n# nope.\ndef countPic(dir=\"celeb_pictures\",minCount=100,realtime=False):\n    ct=os.listdir(dir)\n    ct = [x for x in ct if x.endswith(\".jpeg\") or x.endswith(\".jpg\") or x.endswith(\".png\")]\n    lct = len(ct)\n    print(\"total number:\",lct)\n    if realtime:\n        return lct\n    else:\n        return lct<minCount\nk=[]\na = sys.argv[1:]\nassert len(a) == 1\n# maybe it just open the shit with wrong encoding.\nwith open(a[0],\"r\", encoding='utf-8') as f:\n    # k = f.read().split(\"\\r\\n\")\n    for line in f:\n        k.append(line)\nk = list(set(k))\nif countPic():\n    sysrand.shuffle(k)\n    for x in k:\n        if countPic():\n        # print(\"picture real name\",x)\n            os.system(\"electron.cmd baidu_spider.js {}\".format(encoded(x)))",
        "type": "code",
        "location": "/collector/celeb_picture_collect/collect_pics.py:1-44"
    },
    "53": {
        "file_id": 4,
        "content": "This code is a Python script that reads a file, randomly selects pictures (if needed), and uses electron.cmd to run baidu_spider.js on the selected picture names encoded in base64. It also counts the total number of image files in the \"celeb_pictures\" directory and prints it out if realtime is set to True. The script imports several libraries for encoding, randomization, and file operations.",
        "type": "comment"
    },
    "54": {
        "file_id": 4,
        "content": "        else:\n            print(\"picture is plenty.\")\nelse:\n    print(\"picture is plenty.\")",
        "type": "code",
        "location": "/collector/celeb_picture_collect/collect_pics.py:45-48"
    },
    "55": {
        "file_id": 4,
        "content": "If the image is already available in abundance, this code will print \"picture is plenty.\" It checks if an image exists and prints the message accordingly.",
        "type": "comment"
    },
    "56": {
        "file_id": 5,
        "content": "/collector/celeb_picture_collect/download_pics.py",
        "type": "filepath"
    },
    "57": {
        "file_id": 5,
        "content": "The code imports necessary libraries, defines a function for current timestamp, checks command-line arguments and file existence, decodes a prefix with base64, quotes the keyword for URL encoding, and comments about using electron instead and not caring about duplication.",
        "type": "summary"
    },
    "58": {
        "file_id": 5,
        "content": "import sys\nimport base64\nimport os\nimport time\nimport urllib.parse\ndef now():\n    return round(time.time()*1000)\nag = sys.argv[1:]\nassert len(ag) == 2\nassert os.path.exists(ag[0])\nfpath=ag[0]\ndef decode(string):\n    return base64.b64decode(string).decode()\nfprefix = ag[1]\nadds = 0 \nkeyword = decode(fprefix)\nkeyword_enc=urllib.parse.quote(keyword,\"utf-8\")\n# use electron instead.\n# do not care about duplication. it might always be true.\n# just make sure the subject is not the same when rendering.",
        "type": "code",
        "location": "/collector/celeb_picture_collect/download_pics.py:1-24"
    },
    "59": {
        "file_id": 5,
        "content": "The code imports necessary libraries, defines a function for current timestamp, checks command-line arguments and file existence, decodes a prefix with base64, quotes the keyword for URL encoding, and comments about using electron instead and not caring about duplication.",
        "type": "comment"
    },
    "60": {
        "file_id": 6,
        "content": "/collector/celeb_picture_collect/download_server.py",
        "type": "filepath"
    },
    "61": {
        "file_id": 6,
        "content": "This code imports the necessary libraries and starts a new thread for downloading, which will be useful for asynchronous file downloads.",
        "type": "summary"
    },
    "62": {
        "file_id": 6,
        "content": "# will start another thread for downloading.\nimport threading\nimport requests",
        "type": "code",
        "location": "/collector/celeb_picture_collect/download_server.py:1-3"
    },
    "63": {
        "file_id": 6,
        "content": "This code imports the necessary libraries and starts a new thread for downloading, which will be useful for asynchronous file downloads.",
        "type": "comment"
    },
    "64": {
        "file_id": 7,
        "content": "/collector/celeb_picture_collect/elec_arg.js",
        "type": "filepath"
    },
    "65": {
        "file_id": 7,
        "content": "This code requires the electron module and removes two extra arguments from the process.argv array before logging the updated array. It is likely used for processing command line arguments in an Electron app.",
        "type": "summary"
    },
    "66": {
        "file_id": 7,
        "content": "const {electron} = require ('electron')\n// const args = electron.process.argv\n// including 2 extras.\n// console.log(process.argv)\nvar pargs = process.argv;\npargs.shift();\npargs.shift();\nconsole.log(pargs);",
        "type": "code",
        "location": "/collector/celeb_picture_collect/elec_arg.js:1-8"
    },
    "67": {
        "file_id": 7,
        "content": "This code requires the electron module and removes two extra arguments from the process.argv array before logging the updated array. It is likely used for processing command line arguments in an Electron app.",
        "type": "comment"
    },
    "68": {
        "file_id": 8,
        "content": "/collector/celeb_picture_collect/electron.cmd",
        "type": "filepath"
    },
    "69": {
        "file_id": 8,
        "content": "This code is a batch file for Windows, launched by double-clicking. It executes the \"electron.exe\" program, passing any command line arguments (%*) it receives. The REM comment likely refers to a Baidu image search URL, which might be related to the program's functionality but could also be a placeholder or documentation reference. The \"@echo off\" command ensures that no variable assignments are output during script execution, while the \"\\node_global\\node_modules\\electron\\dist\\\" part seems to indicate the location of the electron executable on the local system.",
        "type": "summary"
    },
    "70": {
        "file_id": 8,
        "content": "@echo off\nREM https://image.baidu.com/search/flip?tn=baiduimage&ie=utf-8&word=def&pn=0&gsm=50&ct=&ic=0&lm=-1&width=0&height=0\n\"E:\\nodejs\\node_global\\node_modules\\electron\\dist\\electron.exe\" %*",
        "type": "code",
        "location": "/collector/celeb_picture_collect/electron.cmd:1-3"
    },
    "71": {
        "file_id": 8,
        "content": "This code is a batch file for Windows, launched by double-clicking. It executes the \"electron.exe\" program, passing any command line arguments (%*) it receives. The REM comment likely refers to a Baidu image search URL, which might be related to the program's functionality but could also be a placeholder or documentation reference. The \"@echo off\" command ensures that no variable assignments are output during script execution, while the \"\\node_global\\node_modules\\electron\\dist\\\" part seems to indicate the location of the electron executable on the local system.",
        "type": "comment"
    },
    "72": {
        "file_id": 9,
        "content": "/collector/celeb_picture_collect/pic_collect.cmd",
        "type": "filepath"
    },
    "73": {
        "file_id": 9,
        "content": "This code collects celebrity pictures and information from a list, ensuring the pictures are at least 1000x in size. It uses Unix-to-DOS file conversion for compatibility and Python script to process the list. The collected faces can then be used with another program, likely \"faceswap.py\".",
        "type": "summary"
    },
    "74": {
        "file_id": 9,
        "content": "@echo off\nmkdir celeb_pictures\nREM flrst let's collect info of celebrities.\nREM and we've got pictures.\nREM make sure pictures are 1000x and more. <- this one is not ramdisked.\nREM make ramdisk if you wish? but it might not be good at all.\nREM generate information then.\nunix2dos celeb_list.txt\npython36 collect_pics.py celeb_list.txt\nREM detect the face then. just put all pics to faceswap.py.",
        "type": "code",
        "location": "/collector/celeb_picture_collect/pic_collect.cmd:1-10"
    },
    "75": {
        "file_id": 9,
        "content": "This code collects celebrity pictures and information from a list, ensuring the pictures are at least 1000x in size. It uses Unix-to-DOS file conversion for compatibility and Python script to process the list. The collected faces can then be used with another program, likely \"faceswap.py\".",
        "type": "comment"
    },
    "76": {
        "file_id": 10,
        "content": "/collector/celeb_picture_collect/queries.js",
        "type": "filepath"
    },
    "77": {
        "file_id": 10,
        "content": "This code retrieves all image links with the \"imglink\" class, stores their src and alt attributes in a Map, removes \"<strong>\" tags from alt text, and logs the resulting Map as JSON.",
        "type": "summary"
    },
    "78": {
        "file_id": 10,
        "content": "var getlink = document.getElementsByClassName(\"imglink\"); \nvar dataOutput = {};\nfor (let links of getlink){for (let link of links.childNodes){try{if (link.tagName.toLowerCase() == \"img\") {dataOutput[link.getAttribute(\"src\")]=link.getAttribute(\"alt\").replace(\"<strong>\",\"\").replace(\"</strong>\",\"\")}}catch(e){}}}\n// then we will get the Map.\nconsole.log(JSON.stringify(dataOutput))",
        "type": "code",
        "location": "/collector/celeb_picture_collect/queries.js:1-5"
    },
    "79": {
        "file_id": 10,
        "content": "This code retrieves all image links with the \"imglink\" class, stores their src and alt attributes in a Map, removes \"<strong>\" tags from alt text, and logs the resulting Map as JSON.",
        "type": "comment"
    },
    "80": {
        "file_id": 11,
        "content": "/collector/chrome_console.js",
        "type": "filepath"
    },
    "81": {
        "file_id": 11,
        "content": "The code establishes an HTTP server with WebSocket functionality, assigns player IDs, manages sessions, and handles incoming messages while logging information and updating session count on client disconnection.",
        "type": "summary"
    },
    "82": {
        "file_id": 11,
        "content": "// Print info about Node.JS version\nconsole.log(new Date() + ' | Using Node ' + process.version + ' version to run server');\n// Setting up server.\nconst http = require('http');\nconst server = http.createServer();\nconst port = 4999;\n// Needed for parsing URLs.\nconst url = require('url');\n// Setting WebSockets\nconst WebSocket = require('ws');\nconst wss = new WebSocket.Server({ noServer: true, clientTracking: true });\n// make this shit accessible via cmdline.\n// Needed to generate player ids\n//const uuidv4 = require('uuid/v4');\nvar Set = require(\"collections/set\");\nvar mySet = new Set();\nvar readline = require('readline');\nvar state=true;\nvar index=0;\nvar rl = readline.createInterface(process.stdin, process.stdout);\nrl.setPrompt('select> ');\nrl.prompt();\nrl.on('line', function(line) {\n\ttry{\n\t\tif (state){\nindex=parseInt(line);\nvar inx=mySet.toArray().length\nif (index<inx){\n//var ws =myArr.toArray()[index];\n\t\trl.setPrompt(index+'> ');\n\t\tstate=false;\n\t\trl.prompt();}else{console.log(\"total \"+inx+\" sessions\");}}else{\n\t\t\tvar ws =mySet.toArray()[index];",
        "type": "code",
        "location": "/collector/chrome_console.js:2-39"
    },
    "83": {
        "file_id": 11,
        "content": "Sets up an HTTP server, initializes a WebSocket server using the WebSocket library, and uses readline to interact with the user for input. The code prompts the user to select a session by entering its index, and once a valid index is provided, it retrieves the corresponding WebSocket instance from the set of connections. If an invalid index is entered, it displays the total number of sessions instead.",
        "type": "comment"
    },
    "84": {
        "file_id": 11,
        "content": "\t\t\tws.send(line);\nstate=true;\n\t\t\trl.setPrompt('select> ');\n    rl.prompt();\n\t\t}}catch(err){console.log(err);state=true;\n\t\t\trl.setPrompt('select> ');\n\t\t\trl.prompt();\n\t\t}\n}).on('close',function(){\n    process.exit(0);\n});\n// Websocket connection handler.\nwss.on('connection', function connection(ws, request) {\n  console.log(new Date() + ' | A new client is connected.');\n  // Assign player Id to connected client.\n  // Registering player with the session.\nmySet.add(ws);\n\tvar id = mySet.toArray().length;\n\tconsole.log(\"new session joined. now \"+id+\" sessions\");\n  // Sending confirm message to the connected client.\n//  ws.send('print(\"hello world\")');\n  // Handle all messages from users.\n  ws.on('message', function(msgStr) {\n    console.log('Message Received: '+msgStr);\n    // Send back the same message.\n    // ws.send(msgStr);\n  });\n  // What to do when client disconnect?\n  ws.on('close', function(connection) {\n\t  mySet.delete(ws);\n\t  var id = mySet.toArray().length;  \n\t  console.log(\"one session closed. now \"+id+\" sessions\");",
        "type": "code",
        "location": "/collector/chrome_console.js:40-75"
    },
    "85": {
        "file_id": 11,
        "content": "Websocket server established for client connections, assigning player IDs and managing sessions. Handles incoming messages from clients and logs the information. Closes the connection when a client disconnects and updates session count accordingly.",
        "type": "comment"
    },
    "86": {
        "file_id": 11,
        "content": "    console.log(new Date() + ' | Closing connection for a client.');\n// remove element.\n    // One of the clients has disconnected.\n  });\n});\n// HTTP Server ==> WebSocket upgrade handling:\nserver.on('upgrade', function upgrade(request, socket, head) {\n    console.log(new Date() + ' | Upgrading http connection to wss: url = '+request.url);\n    // Parsing url from the request.\n    var parsedUrl = url.parse(request.url, true, true);\n    const pathname = parsedUrl.pathname\n    console.log(new Date() + ' | Pathname = '+pathname);\n    // If path is valid connect to the websocket.\n    if (pathname === '/chrome_console') {\n      wss.handleUpgrade(request, socket, head, function done(ws) {\nconsole.log(\"add 1 upgraded.\");\n        wss.emit('connection', ws, request);\n      });\n    } else {\n\t    // no fucking destroy!\n      socket.destroy();\n    }\n});\n// On establishing port listener.\nserver.listen(port, function() {\n    console.log(new Date() + ' | Server is listening on port ' + port);\n    // Server is running.\n});",
        "type": "code",
        "location": "/collector/chrome_console.js:76-110"
    },
    "87": {
        "file_id": 11,
        "content": "The code snippet establishes a WebSocket server that listens for HTTP upgrades, handles the upgrade if the path is '/chrome_console', and closes the connection otherwise. The server also logs relevant events such as connection and port listening.",
        "type": "comment"
    },
    "88": {
        "file_id": 12,
        "content": "/collector/chrome_receive.js",
        "type": "filepath"
    },
    "89": {
        "file_id": 12,
        "content": "The code creates a server that accepts GET and POST requests, storing data in time-stamped files with recursive directory creation. It operates on port 5000 and responds accordingly to valid or undefined requests.",
        "type": "summary"
    },
    "90": {
        "file_id": 12,
        "content": "var http = require('http');\nconst fs = require(\"fs\");\nconst chrome_html = \"/chrome_html\";\nconst chrome_monitor = \"/chrome_monitor\";\nvar monotonic_html=0;\nvar monotonic_monitor=0;\n//logger=require('html-differ/lib/logger')\n//this is too slow.\n//you can use some other abstract syntax. such as monotonic+timestamp.\nconst writeFileRecursive = function(path, buffer, callback){\n    let lastPath = path.substring(0, path.lastIndexOf(\"/\"));\n    fs.mkdir(lastPath, {recursive: true}, (err) => {\n        if (err) return callback(err);\n        fs.writeFile(path, buffer, function(err){\n            if (err) return callback(err);\n            return callback(null);\n        });\n    });\n}\nvar prev=null;\n    var server = http.createServer ( function(request,response){\n    response.writeHead(200,{\"Content-Type\":\"text/plain\"});\n    if(request.method == \"GET\")\n        {\n            response.end(\"received GET request.\")\n        }\n    else if(request.method == \"POST\")\n        {//console.log(request.data);\n\t\tvar body=[]\n\t\trequest.on('data', function(data) {",
        "type": "code",
        "location": "/collector/chrome_receive.js:1-31"
    },
    "91": {
        "file_id": 12,
        "content": "Creates a server that handles GET and POST requests, writing received data to files using recursive directory creation if needed. Uses monotonic timestamp for file names. Previous data is stored in the 'prev' variable.",
        "type": "comment"
    },
    "92": {
        "file_id": 12,
        "content": "      body.push(data)\n      //console.log('Partial body: ' , data)\n    })\n    request.on('end', function() {\n\t    var concatBody=Buffer.concat(body)\n\t    if (request.url == chrome_html){\n\t\t    monotonic_html+=1;\n\t    var next=concatBody.toString('utf-8')\n\t    writeFileRecursive(\"./chrome_html/\"+Date.now()+\"-\"+monotonic_html+\".html\",next,error => {if (error) return console.log(\"error to write file.\\n\"+error.message); console.log(\"saved successfully\");});}\n\t    else if (request.url == chrome_monitor){\nmonotonic_monitor+=1;\n\t    var next=concatBody.toString('utf-8')\n\t    writeFileRecursive(\"./chrome_monitor/\"+Date.now()+\"-\"+monotonic_monitor+\".json\",next,error => {if (error) return console.log(\"error to write file.\\n\"+error.message); console.log(\"saved successfully\");});}\n\t    // why are you doing it?\n\t    // we are going to save the file, in case that you are dumb.\n      console.log('Body From '+request.url+'\\nLength:',concatBody.length)\n      response.writeHead(200, {'Content-Type': 'text/html'})\n\t    // this is not.",
        "type": "code",
        "location": "/collector/chrome_receive.js:32-49"
    },
    "93": {
        "file_id": 12,
        "content": "This code is creating a partial body by pushing data into an array, and once the 'end' event is triggered for the request, it concatenates the body, checks the URL, and writes the file recursively. If the URL matches chrome_html, it increments monotonic_html, otherwise if the URL matches chrome_monitor, it increments monotonic_monitor. Finally, it logs the length of the concatenated body and sends a 200 response with a text/html Content-Type.",
        "type": "comment"
    },
    "94": {
        "file_id": 12,
        "content": "      response.end('post received')\n    })\n        }\n    else\n        {\n            response.end(\"Undefined request .\");\n        }\n});\n//arbitrary path.\nserver.listen(5000);\nconsole.log(\"Server running on port 5000\");\n// the socket port might need some change. do not use the same port?",
        "type": "code",
        "location": "/collector/chrome_receive.js:50-61"
    },
    "95": {
        "file_id": 12,
        "content": "This code sets up a server on port 5000, and handles POST requests. If a valid request is received, it sends \"post received\" response. Otherwise, it responds with \"Undefined request.\" The socket port should be changed to avoid conflicts with other ports.",
        "type": "comment"
    },
    "96": {
        "file_id": 13,
        "content": "/collector/qq_mirai_bot/README",
        "type": "filepath"
    },
    "97": {
        "file_id": 13,
        "content": "Missing dynamic scraping for group, personal, and Qzone features.",
        "type": "summary"
    },
    "98": {
        "file_id": 13,
        "content": "dynamic scraping is still missing.\nincluding group dynamic, personal dynamic, qzone.",
        "type": "code",
        "location": "/collector/qq_mirai_bot/README:1-3"
    },
    "99": {
        "file_id": 13,
        "content": "Missing dynamic scraping for group, personal, and Qzone features.",
        "type": "comment"
    }
}