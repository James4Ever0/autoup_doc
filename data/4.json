{
    "400": {
        "file_id": 62,
        "content": "        # We've now got the db filled with parametrized word counts\n        # We still need to normalize this to represent probabilities\n        for word in self.word_dict:\n            wordsum = 0\n            for nextword in self.word_dict[word]:\n                wordsum += self.word_dict[word][nextword].count\n            if wordsum != 0:\n                for nextword in self.word_dict[word]:\n                    self.word_dict[word][nextword].prob = self.word_dict[word][nextword].count / wordsum\n    def create_sentence(self, start=(\"\",)):\n        # next word\n        sentence = list(start)\n        nxt = self.next_word(start)\n        while nxt:\n            sentence.append(nxt)\n            nxt = self.next_word(sentence[-self.n:])\n        return ' '.join(sentence)\n    def next_word(self, previous_words):\n        \"\"\"The next word that is generated by the Markov Chain\n        depends on a tuple of the previous words from the Chain\"\"\"\n        # The previous words may never have appeared in order in the corpus used to",
        "type": "code",
        "location": "/poster/bilibiliupload/mText.py:80-102"
    },
    "401": {
        "file_id": 62,
        "content": "The code initializes a Markov chain model by calculating word probabilities based on the frequency of words occurring in a given text corpus. The 'create_sentence' method generates a random sentence using the Markov chain model, and the 'next_word' method returns the next word given a sequence of previous words from the corpus.",
        "type": "comment"
    },
    "402": {
        "file_id": 62,
        "content": "        # generate the word_dict. Consequently, we want to try to find the previous \n        # words in orde, but if they are not there, then we remove the earliest word\n        # one by one and recheck. This means that next word depends on the current state\n        # but possible not on the entire state\n        previous_words = tuple(previous_words)\n        if previous_words != (\"\",): # the empty string 1-tuple (singleton tuple) is always there\n            while previous_words not in self.word_dict:\n                previous_words = tuple(previous_words[1:])\n                if not previous_words:\n                    return \"\"\n        frequencies = self.word_dict[previous_words]\n        inv = [(v.prob,k) for k, v in frequencies.items()]\n        p, w = zip(*inv)\n        return np.random.choice(w,1,p)[0]\n    def create_sentences(self, num, start=(\"\",)):\n        par = \"\"\n        for _ in range(num):\n            par = par + self.create_sentence(start)\n        return par",
        "type": "code",
        "location": "/poster/bilibiliupload/mText.py:103-122"
    },
    "403": {
        "file_id": 62,
        "content": "This code generates a word based on the previous words and creates sentences using these words. It checks if the previous words are in the dictionary, removes the earliest word if not found, and selects a random word from the available frequencies. The create_sentences function generates a specified number of sentences, each sentence generated by calling create_sentence with the initial start words.",
        "type": "comment"
    },
    "404": {
        "file_id": 63,
        "content": "/poster/bilibiliupload/main_entrance.sh",
        "type": "filepath"
    },
    "405": {
        "file_id": 63,
        "content": "The script kills any existing python3 trivial_server processes, starts the trivial_server.py, waits for a second, and then runs Bilibili.py.",
        "type": "summary"
    },
    "406": {
        "file_id": 63,
        "content": "#!/bin/bash\nps aux | cat | grep python3 | grep trivial_server | awk '{print $2}' | xargs -iabc  kill -s SIGKILL abc &>/dev/null\npython3 trivial_server.py &\nsleep 1\npython3 Bilibili.py",
        "type": "code",
        "location": "/poster/bilibiliupload/main_entrance.sh:1-5"
    },
    "407": {
        "file_id": 63,
        "content": "The script kills any existing python3 trivial_server processes, starts the trivial_server.py, waits for a second, and then runs Bilibili.py.",
        "type": "comment"
    },
    "408": {
        "file_id": 64,
        "content": "/poster/bilibiliupload/requirements.txt",
        "type": "filepath"
    },
    "409": {
        "file_id": 64,
        "content": "This code is a requirements.txt file specifying the necessary libraries and packages for the project, including selenium, psutil, youtube_dl, Pillow, aiohttp[speedups], Requests, PyYAML, streamlink, a git repository (zhangn1985/ykdl), and rsa.",
        "type": "summary"
    },
    "410": {
        "file_id": 64,
        "content": "selenium>=3.8.1\npsutil>=5.4.6\nyoutube_dl>=2018.11.18\nPillow>=5.2.0\naiohttp[speedups]\nRequests>=2.20.0\nPyYAML>=4.2b1\nstreamlink>=0.14.2\ngit+https://github.com/zhangn1985/ykdl.git\nrsa>=4.6",
        "type": "code",
        "location": "/poster/bilibiliupload/requirements.txt:1-10"
    },
    "411": {
        "file_id": 64,
        "content": "This code is a requirements.txt file specifying the necessary libraries and packages for the project, including selenium, psutil, youtube_dl, Pillow, aiohttp[speedups], Requests, PyYAML, streamlink, a git repository (zhangn1985/ykdl), and rsa.",
        "type": "comment"
    },
    "412": {
        "file_id": 65,
        "content": "/poster/bilibiliupload/title_tweaker.py",
        "type": "filepath"
    },
    "413": {
        "file_id": 65,
        "content": "The code includes functions for text manipulation like random string concatenation, injection, and spacing. It also features `censor()` using 'profanity' library and `markov()` utilizing Markov chain generator to generate new sentences.",
        "type": "summary"
    },
    "414": {
        "file_id": 65,
        "content": "import jieba\nimport random\nfrom better_profanity import profanity\nimport l33t\nfrom mText import Markov\n# this is just demostration.\nsysrand = random.SystemRandom()\ndef randomConcat(x,limit=80):\n    if len(x)>limit:\n        y = random.choice(list(range(len(x)-limit)))\n        return x[y:y+limit]\n    return x\ndef minmax(_min,_max):\n    assert _max>_min\n    _range = _max-_min\n    return sysrand.random()*_range+_min\ndef randomInject(string,x):\n    l = len(string)\n    lp = list(range(0,l))\n    sysrand.shuffle(lp)\n    f = lp[0]\n    a, b = string[0:f], string[f:l]\n    return a+x+b\ndef spacing(string,space):\n    assert len(space)>1\n    return space.join(string)\ndef randomSpacing(string,space,gfactor):\n    out = \"\"\n    for x in string:\n        factor = gfactor()\n        factor = round(factor)\n        assert factor>=1\n        out += x+space*factor\n    return out\ndef leetspeak(string):\n    return l33t.l33t(string)\ndef randomLeet(string,k=0.5):\n    y=\"\"\n    for x in string:\n        if sysrand.random()>k:\n            x=leetspeak(x)\n        y+=x",
        "type": "code",
        "location": "/poster/bilibiliupload/title_tweaker.py:1-50"
    },
    "415": {
        "file_id": 65,
        "content": "Code snippets for various text manipulation functions including random string concatenation, random injection, spacing, random spacing, leet speak conversion, and random leet replacement.",
        "type": "comment"
    },
    "416": {
        "file_id": 65,
        "content": "    return y\ndef censor(string):\n    return profanity.censor(string)\ndef markov(string):\n    mk = Markov()\n    mk.add_to_dict(string)\n    return mk.create_sentence()",
        "type": "code",
        "location": "/poster/bilibiliupload/title_tweaker.py:51-59"
    },
    "417": {
        "file_id": 65,
        "content": "Function `censor()` uses the 'profanity' library to censor a given string, while `markov()` initializes and utilizes a Markov chain generator from the Markov class to create a new sentence based on the provided input.",
        "type": "comment"
    },
    "418": {
        "file_id": 66,
        "content": "/poster/bilibiliupload/trivial_server.py",
        "type": "filepath"
    },
    "419": {
        "file_id": 66,
        "content": "This Python code creates a Tornado web app for renaming files and serving persistent JSON file. The RenameHandler handles GET requests and the MainHandler serves the JSON file. The tweak function modifies the provided file name with random UUIDs and character modifications. Uncertainty about program termination is evident in the code.",
        "type": "summary"
    },
    "420": {
        "file_id": 66,
        "content": "import tornado.ioloop\nimport tornado.web\nimport traceback\nimport urllib.parse\nfrom title_tweaker import randomSpacing, randomLeet, minmax, randomInject, randomConcat\nimport uuid\ndef tweak(name,salt=True,amount=2):\n    assert type(amount) == int\n    assert amount>0\n    if salt:\n        for x in range(amount):\n            name = randomInject(name, str(uuid.uuid4())[x])\n    return randomConcat(randomSpacing(randomLeet(name),\" \",lambda :minmax(1,3)))\nclass RenameHandler(tornado.web.RequestHandler):\n    def get(self):\n        name = \"not_right\"\n        try:\n            name = urllib.parse.unquote_plus(self.get_query_argument(\"name\"))\n        except:\n            traceback.print_exc()\n#        print(dir(self))\n        self.write(tweak(name))\nclass MainHandler(tornado.web.RequestHandler):\n    def get(self):\n        # shall parse url?\n        self.write(\"/root/AGI/AutoUP/.confidential/bilibili_persistent.json\")\n    def make_app():\n        return tornado.web.Application([(r\"/rename\",RenameHandler),(r\"/persistent\",MainHandler),])",
        "type": "code",
        "location": "/poster/bilibiliupload/trivial_server.py:1-31"
    },
    "421": {
        "file_id": 66,
        "content": "This Python code is creating a Tornado web application that can rename files and provide access to a persistent file. The RenameHandler class handles GET requests for renaming files based on user-provided parameters. MainHandler serves a specific persistent JSON file. The tweak function applies various transformations to the provided name, including random insertions of UUIDs and character modifications.",
        "type": "comment"
    },
    "422": {
        "file_id": 66,
        "content": "if __name__ == \"__main__\":\n    app = MainHandler.make_app()\n    app.listen(9999)\n    tornado.ioloop.IOLoop.current().start()\n    exit()\n    # sys.exit()\n    # it works.\n    # how to terminate? pid?\n    # p.terminate()\n    # must be thread?",
        "type": "code",
        "location": "/poster/bilibiliupload/trivial_server.py:32-41"
    },
    "423": {
        "file_id": 66,
        "content": "This code block checks if the script is being run directly and creates a Flask app. It then starts the server on port 9999 using Tornado's IOLoop. The code includes alternative methods for termination, such as sys.exit(), but ultimately it seems to be uncertain about how to properly end the program and considers the possibility of killing the process through a PID or by using p.terminate() in a threaded environment.",
        "type": "comment"
    },
    "424": {
        "file_id": 67,
        "content": "/poster/uploader/README.md",
        "type": "filepath"
    },
    "425": {
        "file_id": 67,
        "content": "This code outlines the steps for uploading a video to Bilibili using a script. It involves uploading the video file, splitting it into chunks and uploading each chunk separately before marking them as complete. Additionally, it requires uploading a cover image and finalizing the post.",
        "type": "summary"
    },
    "426": {
        "file_id": 67,
        "content": "# uploader\nB站(bilibili)脚本投稿实现步骤：\n1. 上传视频文件\n    - 获取上传url\n    - 文件分块上传\n    - 标记上传完成\n2. 投稿\n    - 上传封面图片\n    - 完成投稿",
        "type": "code",
        "location": "/poster/uploader/README.md:1-11"
    },
    "427": {
        "file_id": 67,
        "content": "This code outlines the steps for uploading a video to Bilibili using a script. It involves uploading the video file, splitting it into chunks and uploading each chunk separately before marking them as complete. Additionally, it requires uploading a cover image and finalizing the post.",
        "type": "comment"
    },
    "428": {
        "file_id": 68,
        "content": "/poster/uploader/bilibili.py",
        "type": "filepath"
    },
    "429": {
        "file_id": 68,
        "content": "This code initializes an Uploader instance to upload videos to Bilibili using HTTP PUT requests, verifies metadata format, and authenticates with Bilibili API cookies.",
        "type": "summary"
    },
    "430": {
        "file_id": 68,
        "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport os\nimport re\nimport sys\nimport math\nimport time\nimport json\nimport base64\nimport requests\nimport argparse\nfrom requests.adapters import HTTPAdapter\n# planning using two jsons. one for credential, one for video details.\nclass Uploader(object):\n    def __init__(self,cookie_string):\n        # TODO: 增加登录接口使用账号密码登陆\n        #  get all related shits?\n        cookie = cookie_string\n        self.MAX_RETRYS = 5\n        self.profile = 'ugcupos/yb'\n        self.cdn = 'ws'\n        self.csrf = re.search('bili_jct=(.*?);', cookie + ';').group(1)\n        self.mid = re.search('DedeUserID=(.*?);', cookie + ';').group(1)\n        self.session = requests.session()\n        self.session.mount('https://', HTTPAdapter(max_retries=self.MAX_RETRYS))\n        self.session.headers['cookie'] = cookie\n        self.session.headers['Accept'] = 'application/json, text/javascript, */*; q=0.01'\n        self.session.headers['User-Agent'] = 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36'",
        "type": "code",
        "location": "/poster/uploader/bilibili.py:1-30"
    },
    "431": {
        "file_id": 68,
        "content": "Initializing an instance of the Uploader class with a cookie string, setting maximum retries to 5, defining profile and cdn variables, extracting csrf and mid from the cookie string, creating a session object for HTTP requests, setting headers, and handling potential errors.",
        "type": "comment"
    },
    "432": {
        "file_id": 68,
        "content": "        self.session.headers['Referer'] = 'https://space.bilibili.com/{mid}/#!/'.format(mid=self.mid)\n    def _upload(self, filepath):\n        \"\"\"执行上传文件操作\"\"\"\n        if not os.path.isfile(filepath):\n            print('FILE NOT EXISTS:', filepath, file=sys.stderr)\n            return\n        filename = os.path.basename(filepath)\n        filesize = os.path.getsize(filepath)\n        # 1.获取本次上传所需信息\n        preupload_url = 'https://member.bilibili.com/preupload'\n        params = {\n            'os': 'upos',\n            'r': 'upos',\n            'ssl': '0',\n            'name': filename,\n            'size': filesize,\n            'upcdn': self.cdn,\n            'profile': self.profile,\n        }\n        response = self.session.get(preupload_url, params=params)\n        upload_info = response.json()\n        # 本次上传bilibili端文件名\n        upload_info['bili_filename'] = upload_info['upos_uri'].split('/')[-1].split('.')[0]\n        # 本次上传url\n        endpoint = 'http:%s/' % upload_info['endpoint']\n        upload_url = re.sub(r'^upos://', endpoint, upload_info['upos_uri'])",
        "type": "code",
        "location": "/poster/uploader/bilibili.py:31-61"
    },
    "433": {
        "file_id": 68,
        "content": "Code snippet is part of a Bilibili video uploader. It sets the 'Referer' header, defines an '_upload' method to perform file upload operation, and retrieves pre-upload information by making a GET request with necessary parameters to 'https://member.bilibili.com/preupload'. The obtained info includes the Bilibili endpoint and URL for video upload.",
        "type": "comment"
    },
    "434": {
        "file_id": 68,
        "content": "        print('UPLOAD URL:', upload_url, file=sys.stderr)\n        # 本次上传session\n        upload_session = requests.session()\n        upload_session.mount('http://', HTTPAdapter(max_retries=self.MAX_RETRYS))\n        upload_session.headers['X-Upos-Auth'] = upload_info['auth']\n        # 2.获取本次上传的upload_id\n        response = upload_session.post(upload_url + '?uploads&output=json')\n        upload_info['upload_id'] = response.json()['upload_id']\n        print('UPLOAD INFO:', upload_info, file=sys.stderr)\n        # 3.分块上传文件\n        CHUNK_SIZE = 4 * 1024 * 1024\n        total_chunks = math.ceil(filesize * 1.0 / CHUNK_SIZE)\n        offset = 0\n        chunk = 0\n        parts_info = {'parts': []}\n        fp = open(filepath, 'rb')\n        while True:\n            blob = fp.read(CHUNK_SIZE)\n            if not blob:\n                break\n            params = {\n                'partNumber': chunk + 1,\n                'uploadId': upload_info['upload_id'],\n                'chunk': chunk,\n                'chunks': total_chunks,\n                'size': len(blob),",
        "type": "code",
        "location": "/poster/uploader/bilibili.py:62-90"
    },
    "435": {
        "file_id": 68,
        "content": "This code snippet is responsible for uploading a file to Bilibili using the requests library. It first prints the upload URL and creates a session for handling the upload. Then, it gets the upload ID by posting data to the upload URL and assigns the upload_id to upload_info. The file is then divided into chunks of 4MB each and uploaded one by one using the created session.",
        "type": "comment"
    },
    "436": {
        "file_id": 68,
        "content": "                'start': offset,\n                'end': offset + len(blob),\n                'total': filesize,\n            }\n            response = upload_session.put(upload_url, params=params, data=blob)\n            print('Uploading...',math.floor(chunk / total_chunks  * 100), '%  UPLOAD CHUNK', chunk, ':', response.text, file=sys.stderr)\n            parts_info['parts'].append({\n                'partNumber': chunk + 1,\n                'eTag': 'etag'\n            })\n            chunk += 1\n            offset += len(blob)\n        # 4.标记本次上传完成\n        params = {\n            'output': 'json',\n            'name': filename,\n            'profile': self.profile,\n            'uploadId': upload_info['upload_id'],\n            'biz_id': upload_info['biz_id']\n        }\n        response = upload_session.post(upload_url, params=params, data=parts_info)\n        print('UPLOAD RESULT:', response.text, file=sys.stderr)\n        return upload_info\n    def _cover_up(self, image_path):\n        \"\"\"上传图片并获取图片链接\"\"\"\n        if not os.path.isfile(image_path):",
        "type": "code",
        "location": "/poster/uploader/bilibili.py:91-120"
    },
    "437": {
        "file_id": 68,
        "content": "The code is uploading a file to Bilibili using chunked HTTP PUT requests. It splits the file into chunks, sends each chunk, and then combines them with their respective eTags to finalize the upload. The function also handles uploading an image and returns the upload information, including the result of the upload.",
        "type": "comment"
    },
    "438": {
        "file_id": 68,
        "content": "            return ''\n        fp = open(image_path, 'rb')\n        encode_data = base64.b64encode(fp.read())\n        url='https://member.bilibili.com/x/vu/web/cover/up'\n        data={\n            'cover': b'data:image/jpeg;base64,' + encode_data,\n            'csrf': self.csrf,\n        }\n        response = self.session.post(url, data=data)\n        return response.json()['data']['url']\n    def upload(self, filepath, title, tid, tag='', desc='', source='', cover_path='', dynamic='', no_reprint=1):\n        \"\"\"视频投稿\n        Args:\n            filepath   : 视频文件路径\n            title      : 投稿标题\n            tid        : 投稿频道id,详见https://member.bilibili.com/x/web/archive/pre\n            tag        : 视频标签，多标签使用','号分隔\n            desc       : 视频描述信息\n            source     : 转载视频出处url\n            cover_path : 封面图片路径\n            dynamic    : 分享动态, 比如：\"#周五##放假# 劳资明天不上班\"\n            no_reprint : 1表示不允许转载,0表示允许\n        \"\"\"\n        # TODO:\n        # 1.增加多P上传\n        # 2.对已投稿视频进行删改, 包括删除投稿，修改信息，加P删P等\n        # 上传文件, 获取上传信息\n        upload_info = self._upload(filepath)",
        "type": "code",
        "location": "/poster/uploader/bilibili.py:121-150"
    },
    "439": {
        "file_id": 68,
        "content": "This code is for uploading a video to Bilibili using their API. It requires the file path, title, channel ID (tid), tags, description, source URL, and cover image path as input parameters. The function uses the session post method to send the data to Bilibili's server and returns the response in JSON format containing the uploaded video URL. It also includes TODO items for adding multi-P upload functionality and modifying already posted videos.",
        "type": "comment"
    },
    "440": {
        "file_id": 68,
        "content": "        if not upload_info:\n            return\n        # 获取图片链接\n        cover_url = self._cover_up(cover_path) if cover_path else ''\n        # 版权判断, 转载无版权\n        copyright = 2 if source else 1\n        # tag设置\n        if isinstance(tag, list):\n            tag = ','.join(tag)\n        # 设置视频基本信息\n        params = {\n            'copyright' : copyright,\n            'source'    : source,\n            'title'     : title,\n            'tid'       : tid,\n            'tag'       : tag,\n            'no_reprint': no_reprint,\n            'desc'      : desc,\n            'desc_format_id': 0,\n            'dynamic': dynamic,\n            'cover'     : cover_url,\n            'videos'    : [{\n                'filename': upload_info['bili_filename'],\n                'title'   : title,\n                'desc'    : '',\n            }]\n        }\n        if source:\n            del params['no_reprint']\n        url = 'https://member.bilibili.com/x/vu/web/add?csrf=' + self.csrf\n        response = self.session.post(url, json=params)\n        print('SET VIDEO INFO:', response.text, file=sys.stderr)",
        "type": "code",
        "location": "/poster/uploader/bilibili.py:151-182"
    },
    "441": {
        "file_id": 68,
        "content": "This code uploads a video to Bilibili. It checks if there is upload information, gets the cover image URL and sets copyright, tag, title, description, and other video details. It then sends a POST request with these parameters to the Bilibili API, printing the response for debugging purposes.",
        "type": "comment"
    },
    "442": {
        "file_id": 68,
        "content": "        return response.json()\ndef checkFile(cf):\n    assert cf.startswith(\"/\")\n    assert os.path.exists(cf)\n    assert os.path.isfile(cf)\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='上传bilibili视频')\n    parser.add_argument('-k','--json', help=\"full cookie dump json absolute path\", required=True)\n    parser.add_argument('-f', '--file', help='video file absolute path', required=True)\n#    parser.add_argument('-t', '--title', help='标题', required=True)\n#    parser.add_argument('-c', '--channel', type=int, help='频道id, 详见https://member.bilibili.com/x/web/archive/pre', required=True)\n#    parser.add_argument('-T', '--tag', nargs='*', help='标签')\n    parser.add_argument(\"-m\",\"--metadata\", help=\"json metadata of post information absolute path\", required = True)\n    parser.add_argument('-c', '--cover', help=\"cover picture absolute path\")\n    args = parser.parse_args()\n    checkFile(args.file)\n    checkFile(args.json)\n    musthave = [\"title\",\"tid\"]\n    checkFile(args.metadata)\n    parsed =None",
        "type": "code",
        "location": "/poster/uploader/bilibili.py:183-204"
    },
    "443": {
        "file_id": 68,
        "content": "The code is a Bilibili video uploader. It requires a JSON file with cookies, a video file path, and a metadata file. Optionally, it takes a cover image path and the title and channel ID can be provided. It checks that all required files exist before continuing.",
        "type": "comment"
    },
    "444": {
        "file_id": 68,
        "content": "    with open(args.metadata,\"r\") as fi:\n        parsed = json.loads(fi.read())\n    if parsed == None:\n        print(\"metadata error\")\n    assert type(parsed) == dict\n    key_parsed = list(parsed.keys())\n    for x in musthave:\n        assert x in key_parsed\n    assert type(parsed[\"title\"]) == str\n    assert type(parsed[\"tid\"]) == int\n    title = parsed[\"title\"]\n    assert len(title)>0\n    tid = parsed[\"tid\"]\n    tag=''\n    desc=''\n    source=''\n    cover_path=''\n    dynamic=''\n    no_reprint=1\n    if \"tag\" in key_parsed:\n        assert type(parsed[\"tag\"]) == list\n        for x in parsed[\"tag\"]:\n            assert type(x) == str\n            assert len(x)>0\n            assert \",\" not in x\n        tag = \",\".join(parsed[\"tag\"])\n    if \"desc\" in key_parsed:\n        assert type(parsed[\"desc\"]) == str\n        assert len(parsed[\"desc\"])>0\n        desc = parsed[\"desc\"]\n    if \"source\" in key_parsed:\n        assert type(parsed[\"source\"]) == str\n        source = parsed[\"source\"]\n    if \"cover_path\" in key_parsed:\n        assert type(parsed[\"source_path\"]) == str",
        "type": "code",
        "location": "/poster/uploader/bilibili.py:205-239"
    },
    "445": {
        "file_id": 68,
        "content": "This code checks the metadata file for required fields, verifies their data types and formats, and extracts relevant information to be used in the uploading process. It ensures that the \"title\", \"tid\", optional tags, description, source, and cover path (if provided) are correctly formatted before proceeding.",
        "type": "comment"
    },
    "446": {
        "file_id": 68,
        "content": "        checkFile(parsed[\"source_path\"])\n    if \"dynamic\" in key_parsed:\n        assert type(parsed[\"dynamic\"]) == dict\n        ddyn = parsed[\"dynamic\"]\n        ddyn_keys = list(ddyn.keys())\n        assert len(ddyn_keys) == 2\n        assert \"tags\" in ddyn_keys\n        assert \"content\" in ddyn_keys\n        dtags = ddyn[\"tags\"]\n        dcont = ddyn[\"content\"]\n        assert type(dtags) == list\n        assert type(dcont) == str\n        assert len(dcont)>0\n        assert \"#\" not in dcont\n        for x in dtags:\n            assert type(x) == str\n            assert \"#\" not in x\n            dynamic+=\"#\"+x+\"#\"\n        dynamic+=\" \"+dcont\n    if \"no_reprint\" in key_parsed:\n        nop = parsed[\"no_reprint\"]\n        assert type(nop) == int\n        assert nop in [0,1]\n        no_reprint = nop\n    cookie_string = \"\"\n    cookies = None\n    with open(args.json,\"r\") as f:\n        cookies = json.loads(f.read())\n    assert type(cookies) == dict\n    mustcook = [\"DedeUserID\", \"bili_jct\"]\n    for x in mustcook:\n        assert x in cookies.keys()",
        "type": "code",
        "location": "/poster/uploader/bilibili.py:240-271"
    },
    "447": {
        "file_id": 68,
        "content": "This code checks the source file, validates dynamic content tags and content, ensures no reprint flag is present, and retrieves cookies for Bilibili API authentication. It asserts data types, lengths, and conditions to ensure proper formatting before proceeding with the upload process.",
        "type": "comment"
    },
    "448": {
        "file_id": 68,
        "content": "    ckeys = mustcook+[x for x in cookies.keys() if x not in mustcook]\n#    assert \"bili_jct\" in cookies.keys()\n    for x in ckeys:\n        cookie_string+=x+\"=\"+cookies[x]+\"; \"\n    cookie_string = cookie_string[:-2]\n    uper = Uploader(cookie_string)\n    uper.upload(args.file, title,tid, tag=tag, desc=desc, source=source, cover_path=cover_path, dynamic=dynamic, no_reprint=no_reprint)",
        "type": "code",
        "location": "/poster/uploader/bilibili.py:272-278"
    },
    "449": {
        "file_id": 68,
        "content": "This code retrieves cookies not in \"mustcook\" list, concatenates them into a string, creates an Uploader object with the cookie string, and then uploads a file with specified arguments to Bilibili using the Uploader's upload method.",
        "type": "comment"
    },
    "450": {
        "file_id": 69,
        "content": "/poster/uploader/extract_channels.py",
        "type": "filepath"
    },
    "451": {
        "file_id": 69,
        "content": "This code defines functions for printing and checking data structures, validates JSON input, extracts lists/dictionaries, performs actions on them, tracks pass/fail assertions.",
        "type": "summary"
    },
    "452": {
        "file_id": 69,
        "content": "import json\nobj = None\ndef walk_type(x):\n    for t in x:\n        print(\"id:\",t[\"id\"],\"name:\",t[\"name\"],\"desc:\",t[\"desc\"])\n        if \"children\" in t.keys():\n            walk_type(t[\"children\"])\ndef walk_fav(x):\n    y = x[\"typelist\"]\n    for t in y:\n        print(\"id:\",t[\"id\"],\"name:\",t[\"name\"],\"desc:\",t[\"desc\"])\ndef walk_staff(s):\n    y = s[\"typelist\"]\n    for x in y:\n        print(\"typeid:\",x[\"typeid\"])\n        assert len(x[\"title_ids\"]) == len(x[\"titles\"])\n        for z in range(len(x[\"titles\"])):\n            print(\"title:\",x[\"titles\"][z],\"title_id\",x[\"title_ids\"][z])\n#def \ndef print_act(a):\n    for x in a:\n        print(\"id:\",x[\"id\"],\"name:\",x[\"name\"],\"type\",x[\"type\"],\"protocol:\",x[\"protocol\"])\ndef print_ind(d):\n    for x in d:\n        print(\"id:\",x[\"id\"],\"name:\",x[\"name\"],\"type\",x[\"type\"])\ndef print_show(d):\n    for x in d:\n        print(\"id:\",x[\"id\"],\"name:\",x[\"name\"],\"type\",x[\"type\"])\ndef checkList(l):\n    p, np = 0, 0\n    for x in l:\n        try:\n            assert type(x) == dict\n            xk = x.keys()\n            assert \"id\" in xk",
        "type": "code",
        "location": "/poster/uploader/extract_channels.py:1-35"
    },
    "453": {
        "file_id": 69,
        "content": "This code defines multiple functions for printing and checking data structures containing information about activities, individuals, shows, staff types, and favorites. The \"checkList\" function checks if each element in a list is a dictionary with an 'id' key.",
        "type": "comment"
    },
    "454": {
        "file_id": 69,
        "content": "            assert \"name\" in xk\n            assert \"type\" in xk\n            p +=1\n        except:\n            np+=1\n    print(\"passed\",p,\"not passed\",np)\nwith open(\"channels.json\",\"r\") as f:\n    obj = json.loads(f.read())\nassert type(obj) == dict\nd0k = obj.keys()\nassert obj[\"code\"] == 0\ndt = obj[\"data\"]\nd1k = list(dt)\n#['activities', 'adorders', 'fav', 'industry_list', 'myinfo', 'orders', 'prepay', 'season', 'showtype_list', 'staff_activity_conf', 'staff_conf', 'tag_rule', 'tip', 'typelist', 'video_jam', 'watermark']\nlists = [\"activities\",\"adorders\",\"industry_list\",\"showtype_list\",\"typelist\"]\ndicts = [\"fav\",\"myinfo\",\"prepay\",\"staff_activity_conf\",\"staff_conf\",\"tag_rule\",\"tip\",\"video_jam\",\"watermark\"]\n#for x in d1k:\n#    print(x, type(dt[x]))\n#for x in lists:\n#    print(x)\n#    checkList(dt[x])\nwalk_type(dt[\"typelist\"])\nprint_act(dt[\"activities\"])\nprint_ind(dt[\"industry_list\"])\nprint_show(dt[\"showtype_list\"])\nwalk_fav(dt[\"fav\"])\nwalk_staff(dt[\"staff_activity_conf\"])\nwalk_staff(dt[\"staff_conf\"])",
        "type": "code",
        "location": "/poster/uploader/extract_channels.py:36-63"
    },
    "455": {
        "file_id": 69,
        "content": "The code reads data from a JSON file, checks the validity of the data structure, and extracts specific lists and dictionaries from it. It then performs various functions on these extracted items such as walking through them and printing their contents. The code also keeps track of how many items passed and failed the assertions.",
        "type": "comment"
    },
    "456": {
        "file_id": 70,
        "content": "/pull.cmd",
        "type": "filepath"
    },
    "457": {
        "file_id": 70,
        "content": "This code is a batch file that runs on Windows and executes a Git pull command, pulling the latest changes from the \"origin\" remote repository to the local \"master\" branch. It uses the @echo off command to suppress the display of commands being executed in the command prompt.",
        "type": "summary"
    },
    "458": {
        "file_id": 70,
        "content": "@echo off\ngit pull origin master",
        "type": "code",
        "location": "/pull.cmd:1-2"
    },
    "459": {
        "file_id": 70,
        "content": "This code is a batch file that runs on Windows and executes a Git pull command, pulling the latest changes from the \"origin\" remote repository to the local \"master\" branch. It uses the @echo off command to suppress the display of commands being executed in the command prompt.",
        "type": "comment"
    },
    "460": {
        "file_id": 71,
        "content": "/pull.sh",
        "type": "filepath"
    },
    "461": {
        "file_id": 71,
        "content": "This script executes a Git pull command, fetching and merging changes from the 'origin' remote repository into the local 'master' branch.",
        "type": "summary"
    },
    "462": {
        "file_id": 71,
        "content": "#!/bin/bash\ngit pull origin master",
        "type": "code",
        "location": "/pull.sh:1-2"
    },
    "463": {
        "file_id": 71,
        "content": "This script executes a Git pull command, fetching and merging changes from the 'origin' remote repository into the local 'master' branch.",
        "type": "comment"
    },
    "464": {
        "file_id": 72,
        "content": "/requirements.txt",
        "type": "filepath"
    },
    "465": {
        "file_id": 72,
        "content": "These are dependencies for a project, used by various Python libraries to handle audio and video processing, text-to-speech, network analysis, language processing, and more.",
        "type": "summary"
    },
    "466": {
        "file_id": 72,
        "content": "moviepy\nexrex\nnetworkx\nvidgear\nscikit-video\njieba\nnltk\npyttsx3\ntones\npydub\nlibrosa\npyacoustics\npyAudioAnalysis\npyaudio\npraat-parselmouth\ncrepe\naupyom\nspacy",
        "type": "code",
        "location": "/requirements.txt:1-18"
    },
    "467": {
        "file_id": 72,
        "content": "These are dependencies for a project, used by various Python libraries to handle audio and video processing, text-to-speech, network analysis, language processing, and more.",
        "type": "comment"
    },
    "468": {
        "file_id": 73,
        "content": "/tools/bv2av.js",
        "type": "filepath"
    },
    "469": {
        "file_id": 73,
        "content": "This code converts Baidu (BV) and AliVideo (av) IDs, providing functions for bv2av and av2bv conversions. It also replaces BV URLs with AliVideo URLs using the bvUrl2AvUrl function.",
        "type": "summary"
    },
    "470": {
        "file_id": 73,
        "content": "var args = process.argv;\nvar table = 'fZodR9XQDSUm21yCkr6zBqiveYah8bt4xsWpHnJE7jL5VG3guMTKNPAwcF',\n  tr = {};\nfor (var i = 0; i < 58; i++) {\n  tr[table[i]] = i;\n}\nvar s = [11, 10, 3, 8, 4, 6],\n  xor = 177451812,\n  add = 8728348608;\nfunction bv2av(x) {\n  var r = 0;\n  for (var i = 0; i < 6; i++) {\n    r += tr[x[s[i]]] * 58 ** i;\n  }\n  return (r - add) ^ xor;\n}\nfunction av2bv(x) {\n  x = (x ^ xor) + add;\n  r = 'BV1  4 1 7  '.split('');\n  for (var i = 0; i < 6; i++) {\n    r[s[i]] = table[Math.floor(x / 58 ** i) % 58];\n  }\n  return r.join('');\n}\nfunction bvUrl2AvUrl(url) {\n  return url.replace(/\\/video\\/(BV([a-zA-Z0-9]+))/, function (str, bv) {\n    var avCode = bv2av(bv);\n    return str.replace(bv, 'av' + avCode);\n  });\n}\nargs.shift()\nargs.shift()\nfunction print_help(){console.log(\"command format: (-bv2av BV<remainder>)|(-av2bv av<remainder>)\");}\nif (args.length!==2){print_help();}\nelse {\nif (args[0] == \"-bv2av\"){if (args[1].startsWith(\"BV\")){console.log(\"av\"+bv2av(args[1]))}else{print_help();}}\n\telse if (args[0] == \"-av2bv\"){",
        "type": "code",
        "location": "/tools/bv2av.js:1-41"
    },
    "471": {
        "file_id": 73,
        "content": "This code converts between Baidu Video IDs (BV) and AliVideo IDs (av). It provides functions for bv2av and av2bv conversions. The bvUrl2AvUrl function replaces BV URLs with corresponding aliVideo URLs. If the command format is incorrect, it prints a help message.",
        "type": "comment"
    },
    "472": {
        "file_id": 73,
        "content": "if (args[1].startsWith(\"av\")){console.log(av2bv(args[1].substring(2,args[1].length)))}else{print_help()}}\n\telse{print_help()}\n}",
        "type": "code",
        "location": "/tools/bv2av.js:41-43"
    },
    "473": {
        "file_id": 73,
        "content": "This code snippet checks if the second argument of a function starts with \"av\". If it does, it calls av2bv() function to convert \"av\" to \"bv\". If not, or if the argument is missing, it prints help information.",
        "type": "comment"
    },
    "474": {
        "file_id": 74,
        "content": "/tools/debug-flv",
        "type": "filepath"
    },
    "475": {
        "file_id": 74,
        "content": "This script imports the debug_flv module from flvlib3 and executes its main function. It is part of a larger codebase in the auto-up/tools directory, potentially related to handling FLV files.",
        "type": "summary"
    },
    "476": {
        "file_id": 74,
        "content": "#!/usr/bin/python3\nfrom flvlib3.scripts import debug_flv\ndebug_flv.main()",
        "type": "code",
        "location": "/tools/debug-flv:1-4"
    },
    "477": {
        "file_id": 74,
        "content": "This script imports the debug_flv module from flvlib3 and executes its main function. It is part of a larger codebase in the auto-up/tools directory, potentially related to handling FLV files.",
        "type": "comment"
    },
    "478": {
        "file_id": 75,
        "content": "/tools/index-flv",
        "type": "filepath"
    },
    "479": {
        "file_id": 75,
        "content": "This script imports the index_flv module from flvlib3 and executes its main function. It is likely used for indexing FLV (Flash Video) files.",
        "type": "summary"
    },
    "480": {
        "file_id": 75,
        "content": "#!/usr/bin/python3\nfrom flvlib3.scripts import index_flv\nindex_flv.main()",
        "type": "code",
        "location": "/tools/index-flv:1-4"
    },
    "481": {
        "file_id": 75,
        "content": "This script imports the index_flv module from flvlib3 and executes its main function. It is likely used for indexing FLV (Flash Video) files.",
        "type": "comment"
    },
    "482": {
        "file_id": 76,
        "content": "/tools/stub.js",
        "type": "filepath"
    },
    "483": {
        "file_id": 76,
        "content": "The code reads command-line arguments, checks if the correct format is used and prints a help message if not. It then determines whether to perform \"bv2av\" or \"av2bv\" conversion based on the argument provided.",
        "type": "summary"
    },
    "484": {
        "file_id": 76,
        "content": "var args = process.argv;\nargs.shift()\nargs.shift()\nfunction print_help(){console.log(\"command format: (-bv2av <bv>)|(-av2bv <av>)\");}\nif (args.length!==2){print_help();}\nelse {\nif (args[0] == \"-bv2av\"){}\n\telse if (args[0] == \"-av2bv\"){}\n\telse{print_help()}\n}",
        "type": "code",
        "location": "/tools/stub.js:1-10"
    },
    "485": {
        "file_id": 76,
        "content": "The code reads command-line arguments, checks if the correct format is used and prints a help message if not. It then determines whether to perform \"bv2av\" or \"av2bv\" conversion based on the argument provided.",
        "type": "comment"
    },
    "486": {
        "file_id": 77,
        "content": "/tools/test_debug.sh",
        "type": "filepath"
    },
    "487": {
        "file_id": 77,
        "content": "Running debug-flv tool for HOP.flv file with options -i and -u.",
        "type": "summary"
    },
    "488": {
        "file_id": 77,
        "content": "#!/bin/bash\n./debug-flv -i -u /root/AGI/AutoUP/collector/video_download/bilibili_video/HOP.flv",
        "type": "code",
        "location": "/tools/test_debug.sh:1-2"
    },
    "489": {
        "file_id": 77,
        "content": "Running debug-flv tool for HOP.flv file with options -i and -u.",
        "type": "comment"
    },
    "490": {
        "file_id": 78,
        "content": "/tools/testv2_debug.sh",
        "type": "filepath"
    },
    "491": {
        "file_id": 78,
        "content": "This script is running the \"debug-flv\" tool with input (-i) and user (-u) flags, testing a bilibili video file named \"jojo大战内马尔.flv\" in the \"/root/AGI/AutoUP/collector/video_download/bilibili_video/jojo大战内马尔\" directory.",
        "type": "summary"
    },
    "492": {
        "file_id": 78,
        "content": "#!/bin/bash\n./debug-flv -i -u /root/AGI/AutoUP/collector/video_download/bilibili_video/jojo大战内马尔/jojo大战内马尔.flv",
        "type": "code",
        "location": "/tools/testv2_debug.sh:1-2"
    },
    "493": {
        "file_id": 78,
        "content": "This script is running the \"debug-flv\" tool with input (-i) and user (-u) flags, testing a bilibili video file named \"jojo大战内马尔.flv\" in the \"/root/AGI/AutoUP/collector/video_download/bilibili_video/jojo大战内马尔\" directory.",
        "type": "comment"
    }
}