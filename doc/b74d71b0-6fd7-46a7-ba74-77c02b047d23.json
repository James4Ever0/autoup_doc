{
    "summary": "This code filters and manipulates time intervals from CSV data, calculating skipped range percentages and applying conditions to merge or skip ranges. It adjusts rates until reaching target percentage or exhausting all possible rates, then prints the equilibrium rate and appends it to a list.",
    "details": [
        {
            "comment": "The code defines several functions: \"merge\" merges overlapping time intervals, \"sum_range\" calculates the total length of a range of time intervals, \"skip_range\" skips intervals that overlap with specified start and end times, \"skip_ranges\" applies skipping to multiple ranges at once, and \"skip_sspan\" skips intervals smaller than a given size.",
            "location": "\"/media/root/Prima/works/generated_docs/autoup_doc/src/generator/danmaku_filter/extract_danmaku.py\":0-49",
            "content": "import pandas as pd\nimport numpy as np\nimport copy\nimport math\ndef merge(ttuple):\n    temp_tuple=copy.deepcopy(ttuple)\n    temp_tuple.sort(key=lambda interval: interval[0])\n    merged = [temp_tuple[0]]\n    for current in temp_tuple:\n        previous = merged[-1]\n        if current[0] <= previous[1]:\n            previous[1] = max(previous[1], current[1])\n        else:\n            merged.append(current)\n    return merged\ndef sum_range(r):\n    return sum([x[1]-x[0] for x in r])\ndef skip_range(r,s):\n    x1,y1=s\n    assert x1<y1\n    r0=[]\n    for x in r:\n        x0,y0=x\n        assert x0<y0\n        if max(x0,x1)<min(y0,y1):\n            pass\n        else:\n            r0.append(x)\n    return r0\ndef skip_ranges(r,s):\n    r0=copy.deepcopy(r)\n    for s0 in s:\n        r0=skip_range(r0,s0)\n    return r0\ndef skip_sspan(r,s,inv=False):\n    r0=[]\n    for x in r:\n        if (x[1]-x[0])<s:\n            pass\n        else:\n            # only greater or equal to.\n            r0.append(x)\n    if inv:\n        return [x for x in r if x not in r0]\n    return r0"
        },
        {
            "comment": "This function defines a trial process that takes in csv data, target rate, spans, skips, etc. It performs data filtering and sorts the data into different categories based on specific conditions, such as density exceeding the rate or not. The extracted results are stored in a list of can lists containing start and end indices for each extracted data range.",
            "location": "\"/media/root/Prima/works/generated_docs/autoup_doc/src/generator/danmaku_filter/extract_danmaku.py\":50-80",
            "content": "#print(csv)\n#print(dir(csv))\ndef trial(csv,target,rate,span,skips,sspan,espan,step,rinv=False,inv=False,ahead=False):\n    assert target>0 and target<1\n    assert rate>0\n    assert span>0 and type(span) == int\n    assert sspan>0 and type(sspan) == int\n    assert espan>0 and type(espan) == int\n    assert step>0 and type(step) == int\n    assert type(skips) == list \n    for x0,x1 in skips:\n        assert x0<x1\n        assert type(x0) == type(x1)\n        assert type(x0) == int\n    p=csv[0]\n    final=p.sort_values().to_list()[-1:][0]\n    s=p.groupby(pd.cut(p,np.arange(0,math.floor(final),step))).count()\n#print(s)\n    s0=pd.DataFrame({\"density\":s,\"ema\":s.ewm(span=espan,adjust=False).mean()})\n#print(s0)\n    s1=s0.shape[0]\n    can=[]\n# still counting. factor things out.\n    for x in range(s1):\n        s2=s0.iloc[x]\n        den, ema=s2[\"density\"],s2[\"ema\"]\n        if den>ema*rate and not rinv:\n            print(den,ema,x)\n            xs0=x*step-span\n            xs1=x*step+span\n            can.append([max([xs0,0]),min([final,xs1])]) "
        },
        {
            "comment": "This code filters danmaku data from a CSV file. It calculates the percentage of skipped ranges and applies skipping functions to merge, skip, and skim the ranges based on certain conditions. The code adjusts the rate, trying different rates until it finds one that meets the target percentage or exhausts all possible rates.",
            "location": "\"/media/root/Prima/works/generated_docs/autoup_doc/src/generator/danmaku_filter/extract_danmaku.py\":81-130",
            "content": "        elif den<=ema*rate and rinv:\n            print(den,ema,x)\n            xs0=x*step-span\n            xs1=x*step+span\n            can.append([max([xs0,0]),min([final,xs1])])\n    if ahead:\n        can = skip_ranges(can,skips)\n    merged=merge(can)\n    print(merged)\n    skipped=merged\n    if not ahead:\n        skipped=skip_ranges(merged,skips)\n    print(skipped)\n    skimmed=skip_sspan(skipped,sspan,inv=inv)\n    sr=sum_range(skimmed)\n    rws=sr/final\n    return rws, skimmed\n# get the percentage.\ntarget=0.2\nrate=1.2\nspan=2\nskips=[[0,5],[70,80]]\nsspan=5\nespan=4\nstep=3\nlr=0.1\nrates=[]\nrwss={}\nlastrate=None\ncsv = pd.read_csv(\"danmaku.csv\",header=None)\nwhile True:\n    rws, skipped=trial(csv,target,rate,span,skips,sspan,espan,step)\n    print(\"result\",rws,skipped,rate)\n    lastrate=rate\n    #lastrws=rws\n    rwss[rate]=rws\n    if rws>target:\n        rate+=lr\n    else:\n        rate-=lr\n    if rate<0 or rate>5:\n        print(\"not found.\",rate)\n        break\n    elif rate in rates:\n        rr,rlr=rwss[rate],rwss[lastrate]\n        #print(lastrate,rlr,rate,rr)"
        },
        {
            "comment": "Computes an equilibrium rate based on the previous and current rates, prints it, and breaks the loop. Appends the new rate to the list 'rates'.",
            "location": "\"/media/root/Prima/works/generated_docs/autoup_doc/src/generator/danmaku_filter/extract_danmaku.py\":131-135",
            "content": "        equ=(lastrate*rlr+rate*rr)/(rlr+rr)\n        print(\"found equllibrium.\",equ)\n        break\n    rates.append(rate)\n#change the shit accordingly?"
        }
    ]
}