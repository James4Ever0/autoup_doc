{
    "summary": "This code initializes an Uploader instance to upload videos to Bilibili using HTTP PUT requests, verifies metadata format, and authenticates with Bilibili API cookies.",
    "details": [
        {
            "comment": "Initializing an instance of the Uploader class with a cookie string, setting maximum retries to 5, defining profile and cdn variables, extracting csrf and mid from the cookie string, creating a session object for HTTP requests, setting headers, and handling potential errors.",
            "location": "\"/media/root/Prima/works/generated_docs/autoup_doc/src/poster/uploader/bilibili.py\":0-29",
            "content": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport os\nimport re\nimport sys\nimport math\nimport time\nimport json\nimport base64\nimport requests\nimport argparse\nfrom requests.adapters import HTTPAdapter\n# planning using two jsons. one for credential, one for video details.\nclass Uploader(object):\n    def __init__(self,cookie_string):\n        # TODO: \u589e\u52a0\u767b\u5f55\u63a5\u53e3\u4f7f\u7528\u8d26\u53f7\u5bc6\u7801\u767b\u9646\n        #  get all related shits?\n        cookie = cookie_string\n        self.MAX_RETRYS = 5\n        self.profile = 'ugcupos/yb'\n        self.cdn = 'ws'\n        self.csrf = re.search('bili_jct=(.*?);', cookie + ';').group(1)\n        self.mid = re.search('DedeUserID=(.*?);', cookie + ';').group(1)\n        self.session = requests.session()\n        self.session.mount('https://', HTTPAdapter(max_retries=self.MAX_RETRYS))\n        self.session.headers['cookie'] = cookie\n        self.session.headers['Accept'] = 'application/json, text/javascript, */*; q=0.01'\n        self.session.headers['User-Agent'] = 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36'"
        },
        {
            "comment": "Code snippet is part of a Bilibili video uploader. It sets the 'Referer' header, defines an '_upload' method to perform file upload operation, and retrieves pre-upload information by making a GET request with necessary parameters to 'https://member.bilibili.com/preupload'. The obtained info includes the Bilibili endpoint and URL for video upload.",
            "location": "\"/media/root/Prima/works/generated_docs/autoup_doc/src/poster/uploader/bilibili.py\":30-60",
            "content": "        self.session.headers['Referer'] = 'https://space.bilibili.com/{mid}/#!/'.format(mid=self.mid)\n    def _upload(self, filepath):\n        \"\"\"\u6267\u884c\u4e0a\u4f20\u6587\u4ef6\u64cd\u4f5c\"\"\"\n        if not os.path.isfile(filepath):\n            print('FILE NOT EXISTS:', filepath, file=sys.stderr)\n            return\n        filename = os.path.basename(filepath)\n        filesize = os.path.getsize(filepath)\n        # 1.\u83b7\u53d6\u672c\u6b21\u4e0a\u4f20\u6240\u9700\u4fe1\u606f\n        preupload_url = 'https://member.bilibili.com/preupload'\n        params = {\n            'os': 'upos',\n            'r': 'upos',\n            'ssl': '0',\n            'name': filename,\n            'size': filesize,\n            'upcdn': self.cdn,\n            'profile': self.profile,\n        }\n        response = self.session.get(preupload_url, params=params)\n        upload_info = response.json()\n        # \u672c\u6b21\u4e0a\u4f20bilibili\u7aef\u6587\u4ef6\u540d\n        upload_info['bili_filename'] = upload_info['upos_uri'].split('/')[-1].split('.')[0]\n        # \u672c\u6b21\u4e0a\u4f20url\n        endpoint = 'http:%s/' % upload_info['endpoint']\n        upload_url = re.sub(r'^upos://', endpoint, upload_info['upos_uri'])"
        },
        {
            "comment": "This code snippet is responsible for uploading a file to Bilibili using the requests library. It first prints the upload URL and creates a session for handling the upload. Then, it gets the upload ID by posting data to the upload URL and assigns the upload_id to upload_info. The file is then divided into chunks of 4MB each and uploaded one by one using the created session.",
            "location": "\"/media/root/Prima/works/generated_docs/autoup_doc/src/poster/uploader/bilibili.py\":61-89",
            "content": "        print('UPLOAD URL:', upload_url, file=sys.stderr)\n        # \u672c\u6b21\u4e0a\u4f20session\n        upload_session = requests.session()\n        upload_session.mount('http://', HTTPAdapter(max_retries=self.MAX_RETRYS))\n        upload_session.headers['X-Upos-Auth'] = upload_info['auth']\n        # 2.\u83b7\u53d6\u672c\u6b21\u4e0a\u4f20\u7684upload_id\n        response = upload_session.post(upload_url + '?uploads&output=json')\n        upload_info['upload_id'] = response.json()['upload_id']\n        print('UPLOAD INFO:', upload_info, file=sys.stderr)\n        # 3.\u5206\u5757\u4e0a\u4f20\u6587\u4ef6\n        CHUNK_SIZE = 4 * 1024 * 1024\n        total_chunks = math.ceil(filesize * 1.0 / CHUNK_SIZE)\n        offset = 0\n        chunk = 0\n        parts_info = {'parts': []}\n        fp = open(filepath, 'rb')\n        while True:\n            blob = fp.read(CHUNK_SIZE)\n            if not blob:\n                break\n            params = {\n                'partNumber': chunk + 1,\n                'uploadId': upload_info['upload_id'],\n                'chunk': chunk,\n                'chunks': total_chunks,\n                'size': len(blob),"
        },
        {
            "comment": "The code is uploading a file to Bilibili using chunked HTTP PUT requests. It splits the file into chunks, sends each chunk, and then combines them with their respective eTags to finalize the upload. The function also handles uploading an image and returns the upload information, including the result of the upload.",
            "location": "\"/media/root/Prima/works/generated_docs/autoup_doc/src/poster/uploader/bilibili.py\":90-119",
            "content": "                'start': offset,\n                'end': offset + len(blob),\n                'total': filesize,\n            }\n            response = upload_session.put(upload_url, params=params, data=blob)\n            print('Uploading...',math.floor(chunk / total_chunks  * 100), '%  UPLOAD CHUNK', chunk, ':', response.text, file=sys.stderr)\n            parts_info['parts'].append({\n                'partNumber': chunk + 1,\n                'eTag': 'etag'\n            })\n            chunk += 1\n            offset += len(blob)\n        # 4.\u6807\u8bb0\u672c\u6b21\u4e0a\u4f20\u5b8c\u6210\n        params = {\n            'output': 'json',\n            'name': filename,\n            'profile': self.profile,\n            'uploadId': upload_info['upload_id'],\n            'biz_id': upload_info['biz_id']\n        }\n        response = upload_session.post(upload_url, params=params, data=parts_info)\n        print('UPLOAD RESULT:', response.text, file=sys.stderr)\n        return upload_info\n    def _cover_up(self, image_path):\n        \"\"\"\u4e0a\u4f20\u56fe\u7247\u5e76\u83b7\u53d6\u56fe\u7247\u94fe\u63a5\"\"\"\n        if not os.path.isfile(image_path):"
        },
        {
            "comment": "This code is for uploading a video to Bilibili using their API. It requires the file path, title, channel ID (tid), tags, description, source URL, and cover image path as input parameters. The function uses the session post method to send the data to Bilibili's server and returns the response in JSON format containing the uploaded video URL. It also includes TODO items for adding multi-P upload functionality and modifying already posted videos.",
            "location": "\"/media/root/Prima/works/generated_docs/autoup_doc/src/poster/uploader/bilibili.py\":120-149",
            "content": "            return ''\n        fp = open(image_path, 'rb')\n        encode_data = base64.b64encode(fp.read())\n        url='https://member.bilibili.com/x/vu/web/cover/up'\n        data={\n            'cover': b'data:image/jpeg;base64,' + encode_data,\n            'csrf': self.csrf,\n        }\n        response = self.session.post(url, data=data)\n        return response.json()['data']['url']\n    def upload(self, filepath, title, tid, tag='', desc='', source='', cover_path='', dynamic='', no_reprint=1):\n        \"\"\"\u89c6\u9891\u6295\u7a3f\n        Args:\n            filepath   : \u89c6\u9891\u6587\u4ef6\u8def\u5f84\n            title      : \u6295\u7a3f\u6807\u9898\n            tid        : \u6295\u7a3f\u9891\u9053id,\u8be6\u89c1https://member.bilibili.com/x/web/archive/pre\n            tag        : \u89c6\u9891\u6807\u7b7e\uff0c\u591a\u6807\u7b7e\u4f7f\u7528','\u53f7\u5206\u9694\n            desc       : \u89c6\u9891\u63cf\u8ff0\u4fe1\u606f\n            source     : \u8f6c\u8f7d\u89c6\u9891\u51fa\u5904url\n            cover_path : \u5c01\u9762\u56fe\u7247\u8def\u5f84\n            dynamic    : \u5206\u4eab\u52a8\u6001, \u6bd4\u5982\uff1a\"#\u5468\u4e94##\u653e\u5047# \u52b3\u8d44\u660e\u5929\u4e0d\u4e0a\u73ed\"\n            no_reprint : 1\u8868\u793a\u4e0d\u5141\u8bb8\u8f6c\u8f7d,0\u8868\u793a\u5141\u8bb8\n        \"\"\"\n        # TODO:\n        # 1.\u589e\u52a0\u591aP\u4e0a\u4f20\n        # 2.\u5bf9\u5df2\u6295\u7a3f\u89c6\u9891\u8fdb\u884c\u5220\u6539, \u5305\u62ec\u5220\u9664\u6295\u7a3f\uff0c\u4fee\u6539\u4fe1\u606f\uff0c\u52a0P\u5220P\u7b49\n        # \u4e0a\u4f20\u6587\u4ef6, \u83b7\u53d6\u4e0a\u4f20\u4fe1\u606f\n        upload_info = self._upload(filepath)"
        },
        {
            "comment": "This code uploads a video to Bilibili. It checks if there is upload information, gets the cover image URL and sets copyright, tag, title, description, and other video details. It then sends a POST request with these parameters to the Bilibili API, printing the response for debugging purposes.",
            "location": "\"/media/root/Prima/works/generated_docs/autoup_doc/src/poster/uploader/bilibili.py\":150-181",
            "content": "        if not upload_info:\n            return\n        # \u83b7\u53d6\u56fe\u7247\u94fe\u63a5\n        cover_url = self._cover_up(cover_path) if cover_path else ''\n        # \u7248\u6743\u5224\u65ad, \u8f6c\u8f7d\u65e0\u7248\u6743\n        copyright = 2 if source else 1\n        # tag\u8bbe\u7f6e\n        if isinstance(tag, list):\n            tag = ','.join(tag)\n        # \u8bbe\u7f6e\u89c6\u9891\u57fa\u672c\u4fe1\u606f\n        params = {\n            'copyright' : copyright,\n            'source'    : source,\n            'title'     : title,\n            'tid'       : tid,\n            'tag'       : tag,\n            'no_reprint': no_reprint,\n            'desc'      : desc,\n            'desc_format_id': 0,\n            'dynamic': dynamic,\n            'cover'     : cover_url,\n            'videos'    : [{\n                'filename': upload_info['bili_filename'],\n                'title'   : title,\n                'desc'    : '',\n            }]\n        }\n        if source:\n            del params['no_reprint']\n        url = 'https://member.bilibili.com/x/vu/web/add?csrf=' + self.csrf\n        response = self.session.post(url, json=params)\n        print('SET VIDEO INFO:', response.text, file=sys.stderr)"
        },
        {
            "comment": "The code is a Bilibili video uploader. It requires a JSON file with cookies, a video file path, and a metadata file. Optionally, it takes a cover image path and the title and channel ID can be provided. It checks that all required files exist before continuing.",
            "location": "\"/media/root/Prima/works/generated_docs/autoup_doc/src/poster/uploader/bilibili.py\":182-203",
            "content": "        return response.json()\ndef checkFile(cf):\n    assert cf.startswith(\"/\")\n    assert os.path.exists(cf)\n    assert os.path.isfile(cf)\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='\u4e0a\u4f20bilibili\u89c6\u9891')\n    parser.add_argument('-k','--json', help=\"full cookie dump json absolute path\", required=True)\n    parser.add_argument('-f', '--file', help='video file absolute path', required=True)\n#    parser.add_argument('-t', '--title', help='\u6807\u9898', required=True)\n#    parser.add_argument('-c', '--channel', type=int, help='\u9891\u9053id, \u8be6\u89c1https://member.bilibili.com/x/web/archive/pre', required=True)\n#    parser.add_argument('-T', '--tag', nargs='*', help='\u6807\u7b7e')\n    parser.add_argument(\"-m\",\"--metadata\", help=\"json metadata of post information absolute path\", required = True)\n    parser.add_argument('-c', '--cover', help=\"cover picture absolute path\")\n    args = parser.parse_args()\n    checkFile(args.file)\n    checkFile(args.json)\n    musthave = [\"title\",\"tid\"]\n    checkFile(args.metadata)\n    parsed =None"
        },
        {
            "comment": "This code checks the metadata file for required fields, verifies their data types and formats, and extracts relevant information to be used in the uploading process. It ensures that the \"title\", \"tid\", optional tags, description, source, and cover path (if provided) are correctly formatted before proceeding.",
            "location": "\"/media/root/Prima/works/generated_docs/autoup_doc/src/poster/uploader/bilibili.py\":204-238",
            "content": "    with open(args.metadata,\"r\") as fi:\n        parsed = json.loads(fi.read())\n    if parsed == None:\n        print(\"metadata error\")\n    assert type(parsed) == dict\n    key_parsed = list(parsed.keys())\n    for x in musthave:\n        assert x in key_parsed\n    assert type(parsed[\"title\"]) == str\n    assert type(parsed[\"tid\"]) == int\n    title = parsed[\"title\"]\n    assert len(title)>0\n    tid = parsed[\"tid\"]\n    tag=''\n    desc=''\n    source=''\n    cover_path=''\n    dynamic=''\n    no_reprint=1\n    if \"tag\" in key_parsed:\n        assert type(parsed[\"tag\"]) == list\n        for x in parsed[\"tag\"]:\n            assert type(x) == str\n            assert len(x)>0\n            assert \",\" not in x\n        tag = \",\".join(parsed[\"tag\"])\n    if \"desc\" in key_parsed:\n        assert type(parsed[\"desc\"]) == str\n        assert len(parsed[\"desc\"])>0\n        desc = parsed[\"desc\"]\n    if \"source\" in key_parsed:\n        assert type(parsed[\"source\"]) == str\n        source = parsed[\"source\"]\n    if \"cover_path\" in key_parsed:\n        assert type(parsed[\"source_path\"]) == str"
        },
        {
            "comment": "This code checks the source file, validates dynamic content tags and content, ensures no reprint flag is present, and retrieves cookies for Bilibili API authentication. It asserts data types, lengths, and conditions to ensure proper formatting before proceeding with the upload process.",
            "location": "\"/media/root/Prima/works/generated_docs/autoup_doc/src/poster/uploader/bilibili.py\":239-270",
            "content": "        checkFile(parsed[\"source_path\"])\n    if \"dynamic\" in key_parsed:\n        assert type(parsed[\"dynamic\"]) == dict\n        ddyn = parsed[\"dynamic\"]\n        ddyn_keys = list(ddyn.keys())\n        assert len(ddyn_keys) == 2\n        assert \"tags\" in ddyn_keys\n        assert \"content\" in ddyn_keys\n        dtags = ddyn[\"tags\"]\n        dcont = ddyn[\"content\"]\n        assert type(dtags) == list\n        assert type(dcont) == str\n        assert len(dcont)>0\n        assert \"#\" not in dcont\n        for x in dtags:\n            assert type(x) == str\n            assert \"#\" not in x\n            dynamic+=\"#\"+x+\"#\"\n        dynamic+=\" \"+dcont\n    if \"no_reprint\" in key_parsed:\n        nop = parsed[\"no_reprint\"]\n        assert type(nop) == int\n        assert nop in [0,1]\n        no_reprint = nop\n    cookie_string = \"\"\n    cookies = None\n    with open(args.json,\"r\") as f:\n        cookies = json.loads(f.read())\n    assert type(cookies) == dict\n    mustcook = [\"DedeUserID\", \"bili_jct\"]\n    for x in mustcook:\n        assert x in cookies.keys()"
        },
        {
            "comment": "This code retrieves cookies not in \"mustcook\" list, concatenates them into a string, creates an Uploader object with the cookie string, and then uploads a file with specified arguments to Bilibili using the Uploader's upload method.",
            "location": "\"/media/root/Prima/works/generated_docs/autoup_doc/src/poster/uploader/bilibili.py\":271-277",
            "content": "    ckeys = mustcook+[x for x in cookies.keys() if x not in mustcook]\n#    assert \"bili_jct\" in cookies.keys()\n    for x in ckeys:\n        cookie_string+=x+\"=\"+cookies[x]+\"; \"\n    cookie_string = cookie_string[:-2]\n    uper = Uploader(cookie_string)\n    uper.upload(args.file, title,tid, tag=tag, desc=desc, source=source, cover_path=cover_path, dynamic=dynamic, no_reprint=no_reprint)"
        }
    ]
}